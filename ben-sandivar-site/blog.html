<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Blog Coming Soon â€” Ben Sandivar</title>
  <!-- Use the same favicon as the main site -->
  <link rel="icon" type="image/png" href="assets/favicon.png" />
  <link rel="shortcut icon" href="assets/favicon.png" type="image/png" />
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Gabarito:wght@400;700;900&family=Geologica:wght@300;400;500;700&display=swap" rel="stylesheet" />
  <link href="https://fonts.googleapis.com/icon?family=Material+Symbols+Outlined" rel="stylesheet" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@studio-freight/lenis@1.0.18/bundled/lenis.min.js"></script>
  <link rel="stylesheet" href="styles.css" />
  <style>
    .coming-soon-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 100vh; /* Full-screen height */
      text-align: center;
      position: relative;
      padding: 2rem;
      width: 100%;
      overflow: hidden; /* Prevent clipping */
    }
    /* Style for the swirling blog canvas. This canvas sits behind the coming
       soon content and is much smaller than the hero effect on the home page. */
    #blog-gl {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 500px;
      height: 500px;
      z-index: 0;
      pointer-events: none;
    }
    /* On mobile, reduce the size to keep the effect subtle */
    @media (max-width: 768px) {
      #blog-gl {
        width: 300px !important;
        height: 300px !important;
      }
    }
    .coming-soon-content {
      position: relative;
      z-index: 1;
      max-width:25%;
      background: var(--color-navbar-bg);
      padding: 2rem 3rem;
      border-radius: 16px;
      backdrop-filter: blur(1.5px);
      border: 1px solid var(--color-border);
    }
    .coming-soon-content h1 {
      font-family: var(--font-heading);
      font-size: 1.5rem;
      font-weight: 900;
      color: var(--color-primary);
      margin-bottom: 1rem;
    }
    .coming-soon-content p {
      font-size: 0.7rem;
      color: var(--color-text);
      margin-bottom: 2rem;
    }
    .coming-soon-content a {
      display: inline-block;
      background: var(--color-accent);
      color: #FFFFFF;
      font-weight: 600;
      padding: 0.75rem 1.5rem;
      border-radius: var(--radius);
      text-decoration: none;
      transition: var(--transition);
      font-size: 0.7rem;
    }
    .coming-soon-content a:hover {
      background: #2563EB;
      transform: translateY(-2px);
    }
    @media (max-width: 1300px) {
    .coming-soon-content {
      position: relative;
      z-index: 1;
      max-width:50%;
      }
    }


    @media (max-width: 768px) {
      .coming-soon-container {
        padding: 1rem;
        margin: 0 auto;
      }
      #mini-klein-canvas {
        width: 300px !important;
        height: 300px !important;
      }
      .coming-soon-content {
      position: relative;
      z-index: 1;
      max-width:80%;
      }
      .coming-soon-content h1 {
        font-size: 2rem;
      }
      .coming-soon-content p {
        font-size: 1rem;
      }
      .logo {
        width: 10px;
        height: 10px;
      }
    }
  </style>
</head>
<body>
  <!-- Navbar -->
  <nav class="navbar">
    <div class="nav-container">
      <a href="index.html" class="logo">
        <img src="https://raw.githubusercontent.com/BenS-UI/portfolio/cfc0bc646dc8f7cb21379d516f1b1ca0c0f85e06/B-logo-a.svg" alt="Ben Sandivar Logo" />
      </a>
      <button class="more-btn" aria-label="Toggle Menu">
        <span class="material-symbols-outlined">menu</span>
      </button>
      <!-- Match the home page navigation exactly -->
      <ul class="nav-links">
        <li><a href="../index.html#hero">Home</a></li>
        <li><a href="../index.html#projects">Work</a></li>
        <li><a href="../index.html#music">Music</a></li>
        <li><a href="../index.html#about">About</a></li>
        <li><a href="../index.html#contact">Contact</a></li>
        <li><a href="blog.html">Blog</a></li>
      </ul>
    </div>
  </nav>

  <!-- Coming Soon Section -->
  <section class="coming-soon-container">
    <canvas id="blog-gl"></canvas>
    <div class="coming-soon-content">
      <h1>Blog Coming Soon</h1>
      <p>Stay tuned for insights on design, technology, and creative expression.</p>
      <a href="../index.html#contact" class="scroll-to">Get in Touch</a>
    </div>
  </section>

  <!-- Theme Toggle -->
  <div class="theme-toggle-container">
    <button id="theme-toggle">
      <span class="material-symbols-outlined theme-icon">dark_mode</span>
    </button>
  </div>

  <script src="scripts.js"></script>

  <!-- WebGL2 Nebula-Klein swirl effect for the blog page. This is a smaller version of the
       hero animation. The canvas with id "blog-gl" is sized via CSS. -->
  <script>
  (() => {
    const DPR = Math.min(2, window.devicePixelRatio || 1);
    const canvas = document.getElementById('blog-gl');
    const gl = canvas.getContext('webgl2', { antialias:true, alpha:true, premultipliedAlpha:false });
    if (!gl) { canvas.parentNode.innerHTML = '<div style="padding:20px;font:14px system-ui;color:#fff;background:#000">WebGL2 required</div>'; return; }
    function resize(){
      const w = Math.max(1, canvas.clientWidth), h = Math.max(1, canvas.clientHeight);
      canvas.width = Math.floor(w*DPR); canvas.height = Math.floor(h*DPR);
      gl.viewport(0,0,canvas.width,canvas.height);
    }
    new ResizeObserver(resize).observe(canvas); resize();
    const GRID = 100; // reduced for blog (~10k points)
    const COUNT = GRID*GRID;
    const pointSize = 100.0 * DPR;
    function klein(u,v,m){ const cu=Math.cos(u), su=Math.sin(u); const c2=Math.cos(u*0.9), s2=Math.sin(u*0.2); const sv=Math.sin(v), s2v=Math.sin(2.3*v); let x=(2.0 + c2*sv - s2*s2v)*cu; let y=(2.0 + c2*sv - s2*s2v)*su; let z=s2*sv + c2*s2v; const R=2.5, r=0.85; const xt=(R + r*Math.cos(v))*Math.cos(u); const yt=(R + r*Math.cos(v))*Math.sin(u); const zt=r*Math.sin(v); return [x*(1.0-m)+xt*m, y*(1.0-m)+yt*m, z*(1.0-m)+zt*m]; }
    const pos = new Float32Array(COUNT*3); const vel = new Float32Array(COUNT*3); const uv  = new Float32Array(COUNT*2);
    let i=0; const TWO_PI = Math.PI*2.0; const morph0 = 0.6;
    for (let y=0; y<GRID; y++){
      for (let x=0; x<GRID; x++){
        const u = (x+0.5)/GRID, v = (y+0.5)/GRID;
        uv[i*2] = u; uv[i*2+1] = v;
        const U=u*TWO_PI, V=v*TWO_PI;
        const p = klein(U, V, morph0);
        pos[i*3] = p[0]*2.0; pos[i*3+1] = p[1]*2.0; pos[i*3+2] = p[2]*2.0;
        i++;
      }
    }
    const bufPos = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, bufPos); gl.bufferData(gl.ARRAY_BUFFER, pos, gl.DYNAMIC_DRAW);
    const bufUV  = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, bufUV ); gl.bufferData(gl.ARRAY_BUFFER, uv , gl.STATIC_DRAW);
    const vert = `#version 300 es
    precision highp float;
    layout(location=0) in vec3 a_pos;
    layout(location=1) in vec2 a_uv;
    uniform mat4 u_proj, u_view;
    uniform float u_point;
    uniform float u_time;
    out vec3 v_col;
    out float v_depth;
    out float v_soft;
    vec3 palette(float t){ vec3 indigo = vec3(0.03, 0.00, 0.45); vec3 eblue  = vec3(0.15, 0.30, 0.9); vec3 aqua   = vec3(0.00, 0.58, 0.7); return (t < 0.5) ? mix(indigo, eblue, t*2.0) : mix(eblue, aqua, (t-0.5)*2.0); }
    void main(){ vec4 wp = u_view * vec4(a_pos, 1.0); gl_Position = u_proj * wp; float depth = max(0.0001, -wp.z); gl_PointSize = clamp((u_point / depth) * 16.0, 1.0, 3.0); float base = fract(a_uv.x*0.33 + a_uv.y*0.77); float shift = 0.22 * sin(u_time*0.20 + base*6.2831); float t = fract(base + shift); v_col = normalize(palette(t) + vec3(0.04)); v_depth = depth; v_soft = 0.06; }`;
    const frag = `#version 300 es
    precision highp float;
    in vec3 v_col;
    in float v_depth;
    in float v_soft;
    out vec4 o;
    void main(){ vec2 uv = gl_PointCoord * 2.0 - 1.0; float r2 = dot(uv, uv); if (r2 > 1.0) discard; float core = 1.0 - smoothstep(0.0, 0.85, r2); float glow = smoothstep(0.65, 1.0, r2) * v_soft; float a = clamp(core*0.95 + glow*0.05, 0.0, 0.95); float dim = clamp(1.0 / (1.0 + v_depth*0.25), 0.75, 1.0); vec3 col = v_col * dim; o = vec4(col, a); }`;
    function makeShader(src, type){ const s=gl.createShader(type); gl.shaderSource(s,src); gl.compileShader(s); if(!gl.getShaderParameter(s,gl.COMPILE_STATUS)) throw new Error(gl.getShaderInfoLog(s)); return s; }
    function makeProgram(vs, fs){ const p=gl.createProgram(); gl.attachShader(p,makeShader(vs,gl.VERTEX_SHADER)); gl.attachShader(p,makeShader(fs,gl.FRAGMENT_SHADER)); gl.linkProgram(p); if(!gl.getProgramParameter(p,gl.LINK_STATUS)) throw new Error(gl.getProgramInfoLog(p)); return p; }
    const prog = makeProgram(vert, frag);
    gl.useProgram(prog);
    gl.enable(gl.BLEND); gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
    gl.clearColor(0,0,0,0);
    gl.bindBuffer(gl.ARRAY_BUFFER, bufPos); gl.enableVertexAttribArray(0); gl.vertexAttribPointer(0,3,gl.FLOAT,false,0,0);
    gl.bindBuffer(gl.ARRAY_BUFFER, bufUV ); gl.enableVertexAttribArray(1); gl.vertexAttribPointer(1,2,gl.FLOAT,false,0,0);
    const uni = { proj : gl.getUniformLocation(prog,'u_proj'), view : gl.getUniformLocation(prog,'u_view'), point: gl.getUniformLocation(prog,'u_point'), time : gl.getUniformLocation(prog,'u_time') };
    const projBuf = new Float32Array(16), viewBuf = new Float32Array(16);
    function perspective(fovy, aspect, near, far){ const f = 1/Math.tan(fovy/2), nf = 1/(near-far); projBuf.set([f/aspect,0,0,0, 0,f,0,0, 0,0,(far+near)*nf,-1, 0,0,(2*far*near)*nf,0]); return projBuf; }
    function lookAt(eye,center,up){ const ex=eye[0],ey=eye[1],ez=eye[2]; let fx=center[0]-ex, fy=center[1]-ey, fz=center[2]-ez; let rl=1/Math.hypot(fx,fy,fz); fx*=rl; fy*=rl; fz*=rl; let sx=fy*up[2]-fz*up[1], sy=fz*up[0]-fx*up[2], sz=fx*up[1]-fy*up[0]; rl=1/Math.hypot(sx,sy,sz); sx*=rl; sy*=rl; sz*=rl; const ux=sy*fz-sz*fy, uy=sz*fx-sx*fz, uz=sx*fy-sy*fx; viewBuf.set([ sx,ux,-fx,0, sy,uy,-fy,0, sz,uz,-fz,0, -(sx*ex+sy*ey+sz*ez), -(ux*ex+uy*ey+uz*ez), (fx*ex+fy*ey+fz*ez), 1 ]); return viewBuf; }
    const eye = [0,0,6.0];
    function ndcFromEvent(e){ const r=canvas.getBoundingClientRect(); const x=((e.clientX-r.left)/r.width)*2 - 1; const y=-(((e.clientY-r.top)/r.height)*2 - 1); return [x,y]; }
    function z0World(ndc){ const aspect = canvas.width/canvas.height; const fovy = 60*Math.PI/180; const tanF = Math.tan(fovy/2); const rx = ndc[0]*aspect*tanF; const ry = ndc[1]*tanF; const origin = [0,0,eye[2]]; const dir = [rx,ry,-1]; const t = (0-origin[2])/dir[2]; return [origin[0]+dir[0]*t, origin[1]+dir[1]*t, 0]; }
    let mouse=[999,999,0], mouseSm=[999,999,0], mouseIn=false, prevMouse=[999,999,0];
    canvas.addEventListener('mousemove', e => { prevMouse = mouse.slice(0); mouse = z0World(ndcFromEvent(e)); mouseIn=true; }, {passive:true});
    canvas.addEventListener('mouseleave', () => { mouse=[999,999,0]; mouseIn=false; }, {passive:true});
    canvas.addEventListener('touchmove', e => { const t=e.changedTouches[0], r=canvas.getBoundingClientRect(); const nd=[((t.clientX-r.left)/r.width)*2-1, -(((t.clientY-r.top)/r.height)*2-1)]; prevMouse = mouse.slice(0); mouse = z0World(nd); mouseIn=true; }, {passive:true});
    canvas.addEventListener('touchend', ()=>{ mouse=[999,999,0]; mouseIn=false; }, {passive:true});
    function basis3(x,y,z,t){ const a = Math.sin(0.61*x + 1.21*y + 0.77*z + 0.19*t); const b = Math.sin(1.23*x - 0.97*y + 0.45*z + 0.27*t); const c = Math.sin(-0.73*x + 0.51*y - 1.33*z + 0.31*t); const d = Math.cos(0.89*x - 1.41*y + 0.37*z - 0.17*t); const e = Math.cos(-1.11*x + 0.67*y + 0.91*z + 0.23*t); const f = Math.cos(0.39*x + 0.83*y - 0.59*z - 0.29*t); return [a+d, b+e, c+f]; }
    function curlNoise(px,py,pz,t){ const eps = 0.0015; const f1 = basis3(px, py+eps, pz, t); const f2 = basis3(px, py-eps, pz, t); const f3 = basis3(px, py, pz+eps, t); const f4 = basis3(px, py, pz-eps, t); const f5 = basis3(px+eps, py, pz, t); const f6 = basis3(px-eps, py, pz, t); const dZdy = (f3[2]-f4[2])/(2*eps); const dYdz = (f1[1]-f2[1])/(2*eps); const dXdz = (f3[0]-f4[0])/(2*eps); const dZdx = (f5[2]-f6[2])/(2*eps); const dYdx = (f5[1]-f6[1])/(2*eps); const dXdy = (f1[0]-f2[0])/(2*eps); return [ dZdy - dYdz, dXdz - dZdx, dYdx - dXdy ]; }
    const damp = 0.80; const flowStrength = 1.3; const springK = 2.2; const autopilotSpin = [0.00010*2*Math.PI, 0.000045*2*Math.PI]; const dispersion = 0.3; const mouseVortex = 85.0; const mousePull = 1.0; const mouseRadius = 1.1;
    function rand(i){ const x=Math.sin((i+1)*12.9898)*43758.5453; return (x-Math.floor(x))*2.0-1.0; }
    let prev = performance.now();
    function frame(now){ const dt = Math.min(0.05, (now - prev)/1000); prev = now; const time = now*0.001; gl.useProgram(prog); gl.uniform1f(uni.time, time); const k = 1 - Math.exp(-dt*10.0); mouseSm[0] += (mouse[0]-mouseSm[0])*k; mouseSm[1] += (mouse[1]-mouseSm[1])*k; mouseSm[2] += (mouse[2]-mouseSm[2])*k; const rotY = now*autopilotSpin[0], rotX = now*autopilotSpin[1]; const cy=Math.cos(rotY), sy=Math.sin(rotY); const cx=Math.cos(rotX), sx=Math.sin(rotX); const mvx = (mouseSm[0]-prevMouse[0]) / Math.max(1e-6, dt); const mvy = (mouseSm[1]-prevMouse[1]) / Math.max(1e-6, dt); prevMouse = mouseSm.slice(0); const T = now*0.45; for (let j=0; j<COUNT; j++){ let px = pos[j*3], py = pos[j*3+1], pz = pos[j*3+2]; const u = uv[j*2]*TWO_PI + 0.15*Math.sin(time*0.2); const v = uv[j*2+1]*TWO_PI + 0.12*Math.cos(time*0.17); const morph = 0.55 + 0.45*Math.sin(time*0.07); let tPos = klein(u, v, morph); tPos[0] *= 2.0; tPos[1] *= 2.0; tPos[2] *= 2.0; const rx1 = tPos[0]; const ry1 = tPos[1]*cx - tPos[2]*sx; const rz1 = tPos[1]*sx + tPos[2]*cx; const tx2 = rx1*cy + rz1*sy; const ty2 = ry1; const tz2 = -rx1*sy + rz1*cy; let fx = (tx2 - px)*springK; let fy = (ty2 - py)*springK; let fz = (tz2 - pz)*springK; const c = curlNoise(px*0.2, py*0.2, pz*0.2, T); fx += c[0]*flowStrength; fy += c[1]*flowStrength; fz += c[2]*flowStrength; if (mouseIn){ const dx = mouseSm[0]-px, dy = mouseSm[1]-py, dz = mouseSm[2]-pz; const r2 = dx*dx + dy*dy + dz*dz + 1e-6; const r = Math.sqrt(r2); const falloff = Math.exp(- (r*r) / (mouseRadius*mouseRadius)); const tx = -dy, ty = dx; const swirl = mouseVortex * falloff; fx += tx * swirl * (0.6 + 0.4*Math.tanh(0.002*(mvx*dx + mvy*dy))); fy += ty * swirl * (0.6 + 0.4*Math.tanh(0.002*(mvx*dx + mvy*dy))); fx += dx * mousePull * falloff * 0.35; fy += dy * mousePull * falloff * 0.35; fz += dz * mousePull * falloff * 0.25; } vel[j*3  ] += fx*dt; vel[j*3+1] += fy*dt; vel[j*3+2] += fz*dt; const dj = 0.5*dispersion*dt; vel[j*3  ] += dj * (Math.sin(0.007*j + 1.9*T) + 0.6*rand(j)); vel[j*3+1] += dj * (Math.sin(0.011*j + 2.3*T) + 0.6*rand(j+17)); vel[j*3+2] += dj * (Math.sin(0.013*j + 2.9*T) + 0.6*rand(j+31)); const dampPow = Math.pow(damp, dt*60); vel[j*3  ] *= dampPow; vel[j*3+1] *= dampPow; vel[j*3+2] *= dampPow; pos[j*3  ] = px + vel[j*3  ]*dt; pos[j*3+1] = py + vel[j*3+1]*dt; pos[j*3+2] = pz + vel[j*3+2]*dt; }
      gl.clear(gl.COLOR_BUFFER_BIT); const proj = perspective(60*Math.PI/180, canvas.width/canvas.height, 0.1, 100.0); const view = lookAt(eye, [0,0,0], [0,1,0]); gl.uniformMatrix4fv(uni.proj, false, proj); gl.uniformMatrix4fv(uni.view, false, view); gl.uniform1f(uni.point, pointSize); gl.bindBuffer(gl.ARRAY_BUFFER, bufPos); gl.bufferSubData(gl.ARRAY_BUFFER, 0, pos); gl.drawArrays(gl.POINTS, 0, COUNT); requestAnimationFrame(frame); }
    requestAnimationFrame(frame);
  })();
  </script>
</body>
</html>