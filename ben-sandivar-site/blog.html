<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Blog Coming Soon — Ben Sandivar</title>

  <!-- Favicons -->
  <link rel="icon" type="image/png" href="https://raw.githubusercontent.com/BenS-UI/portfolio/cfc0bc646dc8f7cb21379d516f1b1ca0c0f85e06/B-logo-a.svg" />
  <link rel="shortcut icon" href="https://raw.githubusercontent.com/BenS-UI/portfolio/cfc0bc646dc8f7cb21379d516f1b1ca0c0f85e06/B-logo-a.svg" type="image/png" />

  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Gabarito:wght@400;700;900&family=Geologica:wght@300;400;500;700&display=swap" rel="stylesheet" />
  <link href="https://fonts.googleapis.com/icon?family=Material+Symbols+Outlined" rel="stylesheet" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@studio-freight/lenis@1.0.18/bundled/lenis.min.js"></script>
  <link rel="stylesheet" href="styles.css" />
  <style>
    .coming-soon-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 100vh; /* Full-screen height */
      text-align: center;
      position: relative;
      padding: 2rem;
      width: 100%;
      overflow: hidden; /* Prevent clipping */
    }
    /* Style for the swirling blog canvas. This canvas sits behind the coming
       soon content and is much smaller than the hero effect on the home page. */
    #blog-gl {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 500px;
      height: 500px;
      z-index: 0;
      pointer-events: none;
    }
    /* On mobile, reduce the size to keep the effect subtle */
    @media (max-width: 768px) {
      #blog-gl {
        width: 300px !important;
        height: 300px !important;
      }
    }
    .coming-soon-content {
      position: relative;
      z-index: 1;
      max-width:25%;
      background: var(--color-navbar-bg);
      padding: 2rem 3rem;
      border-radius: 16px;
      backdrop-filter: blur(1.5px);
      border: 1px solid var(--color-border);
    }
    .coming-soon-content h1 {
      font-family: var(--font-heading);
      font-size: 1.5rem;
      font-weight: 900;
      color: var(--color-primary);
      margin-bottom: 1rem;
    }
    .coming-soon-content p {
      font-size: 0.7rem;
      color: var(--color-text);
      margin-bottom: 2rem;
    }
    .coming-soon-content a {
      display: inline-block;
      background: var(--color-accent);
      color: #FFFFFF;
      font-weight: 600;
      padding: 0.75rem 1.5rem;
      border-radius: var(--radius);
      text-decoration: none;
      transition: var(--transition);
      font-size: 0.7rem;
    }
    .coming-soon-content a:hover {
      background: #2563EB;
      transform: translateY(-2px);
    }
    @media (max-width: 1300px) {
    .coming-soon-content {
      position: relative;
      z-index: 1;
      max-width:50%;
      }
    }


    @media (max-width: 768px) {
      .coming-soon-container {
        padding: 1rem;
        margin: 0 auto;
      }
      #mini-klein-canvas {
        width: 300px !important;
        height: 300px !important;
      }
      .coming-soon-content {
      position: relative;
      z-index: 1;
      max-width:80%;
      }
      .coming-soon-content h1 {
        font-size: 2rem;
      }
      .coming-soon-content p {
        font-size: 1rem;
      }
      .logo {
        width: 10px;
        height: 10px;
      }
    }
  </style>
</head>
    <link rel="stylesheet" href="css/navbar.css">
<body>

<!-- /homesplits/navbar.html -->
<nav class="navbar" role="navigation" aria-label="Primary" data-component="navbar">
  <div class="nav-container">
<a href="/#hero" class="logo" aria-label="Ben Sandivar — Home">
    <img src="https://raw.githubusercontent.com/BenS-UI/portfolio/cfc0bc646dc8f7cb21379d516f1b1ca0c0f85e06/B-logo-a.svg" alt="Ben Sandivar Logo" />
  </a>


    <button class="more-btn" aria-label="Toggle Menu" aria-expanded="false">
      <span class="material-symbols-outlined" aria-hidden="true">menu</span>
    </button>

    <ul class="nav-links" id="primary-nav">
      <li><a href="https://bensandivar.com/#hero">Home</a></li>
      <li><a href="https://bensandivar.com/#gallery">Gallery</a></li>
      <li><a href="https://bensandivar.com/#projects">Work</a></li>
      <li><a href="https://bensandivar.com/#music">Music</a></li>
      <li><a href="https://bensandivar.com/#about">About</a></li>
      <li><a href="https://bensandivar.com/#contact">Contact</a></li>
      <li><a href="https://bensandivar.com/buck-it.html">Playground</a></li>
      <li><a href="https://bensandivar.com/blog.html">Blog</a></li>
    </ul>
  </div>

  <script>
    // Tiny, self-contained toggle that won’t conflict with site scripts
    (() => {
      const nav = document.currentScript.closest('nav');
      const btn = nav.querySelector('.more-btn');
      const links = nav.querySelector('.nav-links');

      if (!btn || !links) return;

      const close = () => {
        nav.setAttribute('data-open', 'false');
        btn.setAttribute('aria-expanded', 'false');
      };
      const toggle = () => {
        const open = nav.getAttribute('data-open') === 'true';
        nav.setAttribute('data-open', String(!open));
        btn.setAttribute('aria-expanded', String(!open));
      };

      btn.addEventListener('click', toggle);
      links.addEventListener('click', e => {
        if (e.target.closest('a')) close(); // collapse menu after selecting a link
      });
      // Optional: close on outside click (mobile)
      document.addEventListener('click', e => {
        if (!nav.contains(e.target) && nav.getAttribute('data-open') === 'true') close();
      });
    })();
  </script>
</nav> 

  <!-- Coming Soon Section -->
  <section class="coming-soon-container">
    <canvas id="blog-gl"></canvas>
    <div class="coming-soon-content">
      <h1>Blog Coming Soon</h1>
      <p>Stay tuned for insights on design, technology, and creative expression.</p>
      <a href="../index.html#contact" class="scroll-to">Get in Touch</a>
    </div>
  </section>

  <!-- Theme Toggle -->
  <div class="theme-toggle-container">
    <button id="theme-toggle">
      <span class="material-symbols-outlined theme-icon">dark_mode</span>
    </button>
  </div>

  <script src="scripts.js"></script>

  <!-- WebGL2 Nebula-Klein swirl effect for the blog page. This is a smaller version of the
       hero animation. The canvas with id "blog-gl" is sized via CSS. -->
  <script>
  (() => {
    const DPR = Math.min(2, window.devicePixelRatio || 1);
    const canvas = document.getElementById('blog-gl');
    const gl = canvas.getContext('webgl2', { antialias:true, alpha:true, premultipliedAlpha:false });
    if (!gl) { canvas.parentNode.innerHTML = '<div style="padding:20px;font:14px system-ui;color:#fff;background:#000">WebGL2 required</div>'; return; }
    function resize(){
      const w = Math.max(1, canvas.clientWidth), h = Math.max(1, canvas.clientHeight);
      canvas.width = Math.floor(w*DPR); canvas.height = Math.floor(h*DPR);
      gl.viewport(0,0,canvas.width,canvas.height);
    }
    new ResizeObserver(resize).observe(canvas); resize();
    const GRID = 100; // reduced for blog (~10k points)
    const COUNT = GRID*GRID;
    const pointSize = 100.0 * DPR;
    function klein(u,v,m){ const cu=Math.cos(u), su=Math.sin(u); const c2=Math.cos(u*0.9), s2=Math.sin(u*0.2); const sv=Math.sin(v), s2v=Math.sin(2.3*v); let x=(2.0 + c2*sv - s2*s2v)*cu; let y=(2.0 + c2*sv - s2*s2v)*su; let z=s2*sv + c2*s2v; const R=2.5, r=0.85; const xt=(R + r*Math.cos(v))*Math.cos(u); const yt=(R + r*Math.cos(v))*Math.sin(u); const zt=r*Math.sin(v); return [x*(1.0-m)+xt*m, y*(1.0-m)+yt*m, z*(1.0-m)+zt*m]; }
    const pos = new Float32Array(COUNT*3); const vel = new Float32Array(COUNT*3); const uv  = new Float32Array(COUNT*2);
    let i=0; const TWO_PI = Math.PI*2.0; const morph0 = 0.6;
    for (let y=0; y<GRID; y++){
      for (let x=0; x<GRID; x++){
        const u = (x+0.5)/GRID, v = (y+0.5)/GRID;
        uv[i*2] = u; uv[i*2+1] = v;
        const U=u*TWO_PI, V=v*TWO_PI;
        const p = klein(U, V, morph0);
        pos[i*3] = p[0]*2.0; pos[i*3+1] = p[1]*2.0; pos[i*3+2] = p[2]*2.0;
        i++;
      }
    }
    const bufPos = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, bufPos); gl.bufferData(gl.ARRAY_BUFFER, pos, gl.DYNAMIC_DRAW);
    const bufUV  = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, bufUV ); gl.bufferData(gl.ARRAY_BUFFER, uv , gl.STATIC_DRAW);
    const vert = `#version 300 es
    precision highp float;
    layout(location=0) in vec3 a_pos;
    layout(location=1) in vec2 a_uv;
    uniform mat4 u_proj, u_view;
    uniform float u_point;
    uniform float u_time;
    out vec3 v_col;
    out float v_depth;
    out float v_soft;
    vec3 palette(float t){ vec3 indigo = vec3(0.03, 0.00, 0.45); vec3 eblue  = vec3(0.15, 0.30, 0.9); vec3 aqua   = vec3(0.00, 0.58, 0.7); return (t < 0.5) ? mix(indigo, eblue, t*2.0) : mix(eblue, aqua, (t-0.5)*2.0); }
    void main(){ vec4 wp = u_view * vec4(a_pos, 1.0); gl_Position = u_proj * wp; float depth = max(0.0001, -wp.z); gl_PointSize = clamp((u_point / depth) * 16.0, 1.0, 3.0); float base = fract(a_uv.x*0.33 + a_uv.y*0.77); float shift = 0.22 * sin(u_time*0.20 + base*6.2831); float t = fract(base + shift); v_col = normalize(palette(t) + vec3(0.04)); v_depth = depth; v_soft = 0.06; }`;
    const frag = `#version 300 es
    precision highp float;
    in vec3 v_col;
    in float v_depth;
    in float v_soft;
    out vec4 o;
    void main(){ vec2 uv = gl_PointCoord * 2.0 - 1.0; float r2 = dot(uv, uv); if (r2 > 1.0) discard; float core = 1.0 - smoothstep(0.0, 0.85, r2); float glow = smoothstep(0.65, 1.0, r2) * v_soft; float a = clamp(core*0.95 + glow*0.05, 0.0, 0.95); float dim = clamp(1.0 / (1.0 + v_depth*0.25), 0.75, 1.0); vec3 col = v_col * dim; o = vec4(col, a); }`;
    function makeShader(src, type){ const s=gl.createShader(type); gl.shaderSource(s,src); gl.compileShader(s); if(!gl.getShaderParameter(s,gl.COMPILE_STATUS)) throw new Error(gl.getShaderInfoLog(s)); return s; }
    function makeProgram(vs, fs){ const p=gl.createProgram(); gl.attachShader(p,makeShader(vs,gl.VERTEX_SHADER)); gl.attachShader(p,makeShader(fs,gl.FRAGMENT_SHADER)); gl.linkProgram(p); if(!gl.getProgramParameter(p,gl.LINK_STATUS)) throw new Error(gl.getProgramInfoLog(p)); return p; }
    const prog = makeProgram(vert, frag);
    gl.useProgram(prog);
    gl.enable(gl.BLEND); gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
    gl.clearColor(0,0,0,0);
    gl.bindBuffer(gl.ARRAY_BUFFER, bufPos); gl.enableVertexAttribArray(0); gl.vertexAttribPointer(0,3,gl.FLOAT,false,0,0);
    gl.bindBuffer(gl.ARRAY_BUFFER, bufUV ); gl.enableVertexAttribArray(1); gl.vertexAttribPointer(1,2,gl.FLOAT,false,0,0);
    const uni = { proj : gl.getUniformLocation(prog,'u_proj'), view : gl.getUniformLocation(prog,'u_view'), point: gl.getUniformLocation(prog,'u_point'), time : gl.getUniformLocation(prog,'u_time') };
    const projBuf = new Float32Array(16), viewBuf = new Float32Array(16);
    function perspective(fovy, aspect, near, far){ const f = 1/Math.tan(fovy/2), nf = 1/(near-far); projBuf.set([f/aspect,0,0,0, 0,f,0,0, 0,0,(far+near)*nf,-1, 0,0,(2*far*near)*nf,0]); return projBuf; }
    function lookAt(eye,center,up){ const ex=eye[0],ey=eye[1],ez=eye[2]; let fx=center[0]-ex, fy=center[1]-ey, fz=center[2]-ez; let rl=1/Math.hypot(fx,fy,fz); fx*=rl; fy*=rl; fz*=rl; let sx=fy*up[2]-fz*up[1], sy=fz*up[0]-fx*up[2], sz=fx*up[1]-fy*up[0]; rl=1/Math.hypot(sx,sy,sz); sx*=rl; sy*=rl; sz*=rl; const ux=sy*fz-sz*fy, uy=sz*fx-sx*fz, uz=sx*fy-sy*fx; viewBuf.set([ sx,ux,-fx,0, sy,uy,-fy,0, sz,uz,-fz,0, -(sx*ex+sy*ey+sz*ez), -(ux*ex+uy*ey+uz*ez), (fx*ex+fy*ey+fz*ez), 1 ]); return viewBuf; }
    const eye = [0,0,6.0];
    function ndcFromEvent(e){ const r=canvas.getBoundingClientRect(); const x=((e.clientX-r.left)/r.width)*2 - 1; const y=-(((e.clientY-r.top)/r.height)*2 - 1); return [x,y]; }
    function z0World(ndc){ const aspect = canvas.width/canvas.height; const fovy = 60*Math.PI/180; const tanF = Math.tan(fovy/2); const rx = ndc[0]*aspect*tanF; const ry = ndc[1]*tanF; const origin = [0,0,eye[2]]; const dir = [rx,ry,-1]; const t = (0-origin[2])/dir[2]; return [origin[0]+dir[0]*t, origin[1]+dir[1]*t, 0]; }
    let mouse=[999,999,0], mouseSm=[999,999,0], mouseIn=false, prevMouse=[999,999,0];
    canvas.addEventListener('mousemove', e => { prevMouse = mouse.slice(0); mouse = z0World(ndcFromEvent(e)); mouseIn=true; }, {passive:true});
    canvas.addEventListener('mouseleave', () => { mouse=[999,999,0]; mouseIn=false; }, {passive:true});
    canvas.addEventListener('touchmove', e => { const t=e.changedTouches[0], r=canvas.getBoundingClientRect(); const nd=[((t.clientX-r.left)/r.width)*2-1, -(((t.clientY-r.top)/r.height)*2-1)]; prevMouse = mouse.slice(0); mouse = z0World(nd); mouseIn=true; }, {passive:true});
    canvas.addEventListener('touchend', ()=>{ mouse=[999,999,0]; mouseIn=false; }, {passive:true});
    function basis3(x,y,z,t){ const a = Math.sin(0.61*x + 1.21*y + 0.77*z + 0.19*t); const b = Math.sin(1.23*x - 0.97*y + 0.45*z + 0.27*t); const c = Math.sin(-0.73*x + 0.51*y - 1.33*z + 0.31*t); const d = Math.cos(0.89*x - 1.41*y + 0.37*z - 0.17*t); const e = Math.cos(-1.11*x + 0.67*y + 0.91*z + 0.23*t); const f = Math.cos(0.39*x + 0.83*y - 0.59*z - 0.29*t); return [a+d, b+e, c+f]; }
    function curlNoise(px,py,pz,t){ const eps = 0.0015; const f1 = basis3(px, py+eps, pz, t); const f2 = basis3(px, py-eps, pz, t); const f3 = basis3(px, py, pz+eps, t); const f4 = basis3(px, py, pz-eps, t); const f5 = basis3(px+eps, py, pz, t); const f6 = basis3(px-eps, py, pz, t); const dZdy = (f3[2]-f4[2])/(2*eps); const dYdz = (f1[1]-f2[1])/(2*eps); const dXdz = (f3[0]-f4[0])/(2*eps); const dZdx = (f5[2]-f6[2])/(2*eps); const dYdx = (f5[1]-f6[1])/(2*eps); const dXdy = (f1[0]-f2[0])/(2*eps); return [ dZdy - dYdz, dXdz - dZdx, dYdx - dXdy ]; }
    const damp = 0.80; const flowStrength = 1.3; const springK = 2.2; const autopilotSpin = [0.00010*2*Math.PI, 0.000045*2*Math.PI]; const dispersion = 0.3; const mouseVortex = 85.0; const mousePull = 1.0; const mouseRadius = 1.1;
    function rand(i){ const x=Math.sin((i+1)*12.9898)*43758.5453; return (x-Math.floor(x))*2.0-1.0; }
    let prev = performance.now();
    function frame(now){ const dt = Math.min(0.05, (now - prev)/1000); prev = now; const time = now*0.001; gl.useProgram(prog); gl.uniform1f(uni.time, time); const k = 1 - Math.exp(-dt*10.0); mouseSm[0] += (mouse[0]-mouseSm[0])*k; mouseSm[1] += (mouse[1]-mouseSm[1])*k; mouseSm[2] += (mouse[2]-mouseSm[2])*k; const rotY = now*autopilotSpin[0], rotX = now*autopilotSpin[1]; const cy=Math.cos(rotY), sy=Math.sin(rotY); const cx=Math.cos(rotX), sx=Math.sin(rotX); const mvx = (mouseSm[0]-prevMouse[0]) / Math.max(1e-6, dt); const mvy = (mouseSm[1]-prevMouse[1]) / Math.max(1e-6, dt); prevMouse = mouseSm.slice(0); const T = now*0.45; for (let j=0; j<COUNT; j++){ let px = pos[j*3], py = pos[j*3+1], pz = pos[j*3+2]; const u = uv[j*2]*TWO_PI + 0.15*Math.sin(time*0.2); const v = uv[j*2+1]*TWO_PI + 0.12*Math.cos(time*0.17); const morph = 0.55 + 0.45*Math.sin(time*0.07); let tPos = klein(u, v, morph); tPos[0] *= 2.0; tPos[1] *= 2.0; tPos[2] *= 2.0; const rx1 = tPos[0]; const ry1 = tPos[1]*cx - tPos[2]*sx; const rz1 = tPos[1]*sx + tPos[2]*cx; const tx2 = rx1*cy + rz1*sy; const ty2 = ry1; const tz2 = -rx1*sy + rz1*cy; let fx = (tx2 - px)*springK; let fy = (ty2 - py)*springK; let fz = (tz2 - pz)*springK; const c = curlNoise(px*0.2, py*0.2, pz*0.2, T); fx += c[0]*flowStrength; fy += c[1]*flowStrength; fz += c[2]*flowStrength; if (mouseIn){ const dx = mouseSm[0]-px, dy = mouseSm[1]-py, dz = mouseSm[2]-pz; const r2 = dx*dx + dy*dy + dz*dz + 1e-6; const r = Math.sqrt(r2); const falloff = Math.exp(- (r*r) / (mouseRadius*mouseRadius)); const tx = -dy, ty = dx; const swirl = mouseVortex * falloff; fx += tx * swirl * (0.6 + 0.4*Math.tanh(0.002*(mvx*dx + mvy*dy))); fy += ty * swirl * (0.6 + 0.4*Math.tanh(0.002*(mvx*dx + mvy*dy))); fx += dx * mousePull * falloff * 0.35; fy += dy * mousePull * falloff * 0.35; fz += dz * mousePull * falloff * 0.25; } vel[j*3  ] += fx*dt; vel[j*3+1] += fy*dt; vel[j*3+2] += fz*dt; const dj = 0.5*dispersion*dt; vel[j*3  ] += dj * (Math.sin(0.007*j + 1.9*T) + 0.6*rand(j)); vel[j*3+1] += dj * (Math.sin(0.011*j + 2.3*T) + 0.6*rand(j+17)); vel[j*3+2] += dj * (Math.sin(0.013*j + 2.9*T) + 0.6*rand(j+31)); const dampPow = Math.pow(damp, dt*60); vel[j*3  ] *= dampPow; vel[j*3+1] *= dampPow; vel[j*3+2] *= dampPow; pos[j*3  ] = px + vel[j*3  ]*dt; pos[j*3+1] = py + vel[j*3+1]*dt; pos[j*3+2] = pz + vel[j*3+2]*dt; }
      gl.clear(gl.COLOR_BUFFER_BIT); const proj = perspective(60*Math.PI/180, canvas.width/canvas.height, 0.1, 100.0); const view = lookAt(eye, [0,0,0], [0,1,0]); gl.uniformMatrix4fv(uni.proj, false, proj); gl.uniformMatrix4fv(uni.view, false, view); gl.uniform1f(uni.point, pointSize); gl.bindBuffer(gl.ARRAY_BUFFER, bufPos); gl.bufferSubData(gl.ARRAY_BUFFER, 0, pos); gl.drawArrays(gl.POINTS, 0, COUNT); requestAnimationFrame(frame); }
    requestAnimationFrame(frame);
  })();
  </script>

<!-- Circle of Fifths Synth Widget — v4 -->
<script>
(() => {
  const WIDGET_ID = "circle-fifths-synth-widget";
  if (document.getElementById(WIDGET_ID)) return;

  // ---------- tiny helpers ----------
  const el = (tag, attrs = {}, children = []) => {
    const n = document.createElement(tag);
    for (const [k, v] of Object.entries(attrs)) {
      if (k === "style") Object.assign(n.style, v);
      else if (k === "class") n.className = v;
      else if (k.startsWith("on") && typeof v === "function") n.addEventListener(k.slice(2), v);
      else n.setAttribute(k, v);
    }
    const list = Array.isArray(children) ? children : [children];
    for (const c of list) if (c != null) n.appendChild(typeof c === "string" ? document.createTextNode(c) : c);
    return n;
  };
  const clamp = (v, a, b) => Math.min(Math.max(v, a), b);
  const midiToHz = m => 440 * Math.pow(2, (m - 69) / 12);
  const PC = n => ((n % 12) + 12) % 12;

  // ---------- music ----------
  const NAMES = ["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"];
  const FIFTHS = [0,7,2,9,4,11,6,1,8,3,10,5];
  const MAJOR = [0,2,4,5,7,9,11];
  const MINOR = [0,2,3,5,7,8,10];
  const INTERVALS = { "m3":3,"M3":4,"P5":7,"m7":10,"M7":11,"P8":12,"M9":14,"P11":17 };

  // ---------- audio ----------
  const audio = {
    ctx:null, master:null, analyser:null, dryGain:null, filter:null, pan:null,
    delay:null, delayGain:null, delayFeedback:null,
    lfo:null, lfoGain:null, lfoTarget:"pitch",
    started:false, muted:false,
    settings:{
      waveform:"sine", attack:0.01, decay:0.15, sustain:0.6, release:0.4,
      cutoff:8000, resonance:0.8, detune:0, glide:0.0, volume:0.8,
      delayTime:0.18, delayMix:0.28, delayFeedback:0.32,
      lfoRate:5, lfoAmount:0
    }
  };
  const now = () => (audio.ctx ? audio.ctx.currentTime : 0);

  function initAudio(){
    if (audio.ctx) return;
    const AC = window.AudioContext || window.webkitAudioContext;
    audio.ctx = new AC();
    const ctx = audio.ctx;

    audio.master = ctx.createGain(); audio.master.gain.value = audio.settings.volume;
    audio.analyser = ctx.createAnalyser(); audio.analyser.fftSize = 256;

    audio.dryGain = ctx.createGain(); audio.dryGain.gain.value = 1;
    audio.filter = ctx.createBiquadFilter(); audio.filter.type="lowpass";
    audio.filter.frequency.value = audio.settings.cutoff; audio.filter.Q.value = audio.settings.resonance;
    audio.pan = ctx.createStereoPanner(); audio.pan.pan.value = 0;

    audio.delay = ctx.createDelay(1.5); audio.delay.delayTime.value = audio.settings.delayTime;
    audio.delayGain = ctx.createGain(); audio.delayGain.gain.value = audio.settings.delayMix;
    audio.delayFeedback = ctx.createGain(); audio.delayFeedback.gain.value = audio.settings.delayFeedback;
    audio.delay.connect(audio.delayFeedback); audio.delayFeedback.connect(audio.delay);
    audio.delay.connect(audio.delayGain);

    audio.lfo = ctx.createOscillator(); audio.lfo.type="sine"; audio.lfo.frequency.value = audio.settings.lfoRate;
    audio.lfoGain = ctx.createGain(); audio.lfoGain.gain.value = audio.settings.lfoAmount;
    audio.lfo.connect(audio.lfoGain); audio.lfo.start();

    // mix
    audio.dryGain.connect(audio.filter);
    audio.delayGain.connect(audio.filter);
    audio.filter.connect(audio.pan);
    audio.pan.connect(audio.master);

    // split to analyser + speakers
    audio.master.connect(audio.analyser);
    audio.master.connect(ctx.destination);
  }
  function resumeAudio(){ initAudio(); if (audio.ctx.state!=="running") audio.ctx.resume(); audio.started=true; audio.muted=false; updatePelletIcons(); }
  function suspendAudio(){ if (audio.ctx && audio.ctx.state==="running") audio.ctx.suspend(); audio.muted=true; updatePelletIcons(); }

  // voices
  const sustained = new Map(); // pc -> Set(oct)
  const voices = new Map();    // "pc:oct" -> nodes
  const hoverNotes = new Set();
  const lastAlt = new Map();   // pc -> "up"|"down"

  function attachLFOToVoice(v){
    if (!audio.lfo || !audio.lfoGain) return;
    audio.lfoGain.disconnect();
    if (audio.lfoTarget === "pitch") audio.lfoGain.connect(v.osc.detune);
    else audio.lfoGain.connect(audio.filter.frequency);
  }

  function createVoice(pc, octave, {ephemeral=false}={}){
    const ctx = audio.ctx;
    const osc = ctx.createOscillator();
    const amp = ctx.createGain();
    osc.type = audio.settings.waveform;
    osc.detune.value = audio.settings.detune;

    const midi = 12*(octave+1)+pc;
    const freq = midiToHz(midi);

    const glide = clamp(audio.settings.glide, 0, 1);
    if (glide>0 && voices.size){
      let sum=0,n=0; for(const k of voices.keys()){ const [spc,so]=k.split(":").map(Number); sum+=12*(so+1)+spc; n++; }
      const fromHz = midiToHz(sum/n);
      osc.frequency.setValueAtTime(fromHz, ctx.currentTime);
      osc.frequency.exponentialRampToValueAtTime(freq, ctx.currentTime + glide);
    } else {
      osc.frequency.setValueAtTime(freq, ctx.currentTime);
    }

    // ADSR
    const t0 = ctx.currentTime;
    const A = clamp(audio.settings.attack, 0.001, 2);
    const D = clamp(audio.settings.decay, 0, 2);
    const S = clamp(audio.settings.sustain, 0, 1);
    const R = clamp(audio.settings.release, 0.02, 4);
    amp.gain.cancelScheduledValues(t0);
    amp.gain.setValueAtTime(0.0001, t0);
    amp.gain.exponentialRampToValueAtTime(1.0, t0 + A);
    amp.gain.exponentialRampToValueAtTime(Math.max(S,0.0001), t0 + A + D);

    osc.connect(amp); amp.connect(audio.dryGain); amp.connect(audio.delay);
    attachLFOToVoice({osc});
    osc.start();

    const key = `${pc}:${octave}`;
    const pack = {osc, amp, key, release: () => {
      const t = ctx.currentTime;
      amp.gain.cancelScheduledValues(t);
      amp.gain.setValueAtTime(amp.gain.value, t);
      amp.gain.exponentialRampToValueAtTime(0.0001, t + R);
      setTimeout(()=>{ try{osc.stop()}catch{}; try{osc.disconnect()}catch{}; try{amp.disconnect()}catch{}; }, (R+0.06)*1000);
    }};
    if (!ephemeral) voices.set(key, pack);
    return pack;
  }

  function startSustain(pc, octave){ const set = sustained.get(pc) || new Set(); if (!set.has(octave)){ set.add(octave); sustained.set(pc,set); createVoice(pc, octave); syncArcs(); } }
  function stopSustainNote(pc){
    const set = sustained.get(pc); if(!set) return;
    for (const oct of set){ const k=`${pc}:${oct}`; const v=voices.get(k); if(v){v.release(); voices.delete(k);} }
    sustained.delete(pc); syncArcs();
  }
  function stopAllSustain(){ for (const v of voices.values()) v.release(); voices.clear(); sustained.clear(); syncArcs(); }
  function hoverPlay(pc, octave, dur=0.35){
    const v = createVoice(pc, octave, {ephemeral:true});
    const key = `h:${pc}:${octave}:${Math.random().toString(36).slice(2)}`;
    hoverNotes.add(key); setTimeout(()=>{ v.release(); hoverNotes.delete(key); }, dur*1000);
  }
  function pickNextOctave(pc){
    const set = sustained.get(pc) || new Set();
    const order = [4,5,3,6,2]; for (const o of order) if (!set.has(o)) return o;
    let o=4; while(set.has(o)) o++; return clamp(o,1,7);
  }

  // ---------- UI (Shadow DOM) ----------
  const SIZE = { w: 780, h: 900 };         // bigger frame
  const CIRCLE = { size: 300, radius: 50 }; // smaller wheel for playability
  const NOTE_DIAM = 45;

  const host = el("div", { id: WIDGET_ID });
  Object.assign(host.style, { position:"fixed", right:"24px", bottom:"24px", width: SIZE.w+"px", height: SIZE.h+"px", zIndex: 2147483000 });
  document.body.appendChild(host);
  const root = host.attachShadow({mode:"open"});

  const style = el("style", {}, `
    :host { all: initial; }
    * { box-sizing: border-box; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial; }
    .wrap {
      position: relative; width:100%; height:100%;
      display:grid; grid-template-rows: auto auto 1fr auto;
      border-radius:20px;
      background: rgba(10,12,16,0.58); /* darker glass for white pages */
      box-shadow: 0 24px 52px rgba(0,0,0,0.55), inset 0 1px 0 rgba(255,255,255,0.12);
      backdrop-filter: blur(16px) saturate(160%);
      border: 1px solid rgba(255,255,255,0.22);
      color:#f0fbff; overflow:hidden;
      padding-bottom: 24px; /* bottom space */
    }
    .hdr{
      display:flex; align-items:center; gap:10px; padding:10px 12px; cursor:grab; user-select:none;
      background: linear-gradient(180deg, rgba(255,255,255,0.10), rgba(255,255,255,0.05));
    }
    .dot{ width:10px; height:10px; border-radius:50%; background:#22d3ee; box-shadow:0 0 10px #22d3ee; }
    .title{ font-weight:600; font-size:14px; color:#eaffff; letter-spacing:0.2px; }
    .btn,.toggle{
      font-size:12px; color:#eaffff; background: rgba(255,255,255,0.08);
      border:1px solid rgba(255,255,255,0.24); padding:6px 10px; border-radius:12px;
      backdrop-filter: blur(6px); cursor:pointer; transition: transform .06s ease, background .2s ease;
    }
    .btn:active,.toggle:active{ transform:scale(0.98); }
    .btn-row{ display:flex; gap:8px; align-items:center; padding:8px 12px; flex-wrap:wrap; }
    .circle{ position:relative; width:${CIRCLE.size}px; height:${CIRCLE.size}px; margin: 8px auto 0; }
    .note{
      position:absolute; width:${NOTE_DIAM}px; height:${NOTE_DIAM}px; border-radius:50%;
      display:flex; align-items:center; justify-content:center;
      color:#eaffff; font-weight:700; font-size:13px; letter-spacing:0.4px;
      background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.28), rgba(255,255,255,0.10));
      border:1px solid rgba(255,255,255,0.28);
      box-shadow: inset 0 2px 8px rgba(255,255,255,0.18), 0 0 0 2px rgba(255,255,255,0.06);
      transition: transform .08s ease, box-shadow .2s ease, opacity .2s ease;
      user-select:none;
    }
    .note:hover{ transform:scale(1.06); }
    .inactive{ opacity:.25; pointer-events:none; }
    .active{ box-shadow: inset 0 2px 8px rgba(255,255,255,0.18), 0 0 18px 2px rgba(56,189,248,0.95); }
    .home{ transform: scale(1.14); box-shadow: inset 0 2px 8px rgba(255,255,255,0.18), 0 0 22px 3px rgba(34,211,238,0.95); }

    /* SVG plasma layers */
    .svg{ position:absolute; inset:0; pointer-events:none; mix-blend-mode:screen; }
    .knobs{
      display:grid; grid-template-columns: repeat(6, 1fr); gap:12px;
      padding: 10px 12px 36px; /* extra bottom space */
    }

    /* Rotary knobs: smaller for density */
    .knob{ display:flex; flex-direction:column; align-items:center; gap:6px; color:#eaffff; }
    .dial{
      position:relative; width:58px; height:58px; border-radius:50%;
      background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.18), rgba(255,255,255,0.06));
      border:1px solid rgba(255,255,255,0.25);
      box-shadow: inset 0 2px 10px rgba(0,0,0,0.35), 0 4px 12px rgba(0,0,0,0.25);
      cursor: grab;
    }
    .dial:active{ cursor:grabbing; }
    .dial .arc{
      position:absolute; inset:6px; border-radius:50%;
      background: conic-gradient(from 225deg, #38bdf8 var(--pct,0%), rgba(255,255,255,0.08) 0%);
      filter: drop-shadow(0 0 6px rgba(56,189,248,0.6));
    }
    .dial .cap{
      position:absolute; left:50%; top:50%; width:28px; height:28px; border-radius:50%;
      transform: translate(-50%,-50%) rotate(var(--deg,0deg));
      background: radial-gradient(circle at 35% 35%, rgba(255,255,255,0.25), rgba(255,255,255,0.08));
      border:1px solid rgba(255,255,255,0.25);
      box-shadow: inset 0 1px 6px rgba(0,0,0,0.35);
    }
    .dial .tick{
      position:absolute; left:50%; top:6px; width:3px; height:8px; border-radius:2px;
      transform: translateX(-50%) rotate(var(--deg,0deg)); transform-origin: 50% 23px;
      background:#7de3ff; filter: drop-shadow(0 0 5px rgba(125,227,255,0.9));
    }
    .knob label{ font-size:11px; opacity:.9; }

    /* Editable numeric value */
    .val{
      width:72px; text-align:center; padding:3px 6px; border-radius:8px;
      border:1px solid rgba(255,255,255,0.18);
      background:#000; color:#fff; font-size:11px;
      outline:none;
    }

    /* Black selects for contrast */
    select{
      width:100%; padding:6px 8px; border-radius:10px;
      border:1px solid rgba(255,255,255,0.28);
      background:#000; color:#fff; font-size:12px;
    }

    .spacer{ flex:1; }
    .power.on{ background: linear-gradient(180deg, rgba(34,211,238,0.6), rgba(59,130,246,0.45)); }
    .small{ font-size:11px; color:#e7faff; opacity:0.85; }

    /* Minimize pellet with mute + expand controls */
    .pellet{
      position:absolute; right:6px; bottom:6px; width:66px; height:66px; border-radius:50%;
      display:none; align-items:center; justify-content:center; gap:4px; flex-direction:column;
      color:#eaffff; font-weight:700;
      background: rgba(10,12,16,0.6);
      border:1px solid rgba(255,255,255,0.22);
      box-shadow: 0 12px 24px rgba(0,0,0,0.45), inset 0 1px 0 rgba(255,255,255,0.12);
      backdrop-filter: blur(12px) saturate(160%);
    }
    .pellet .row{ display:flex; gap:6px; }
    .mini{
      width:24px; height:24px; border-radius:8px; display:flex; align-items:center; justify-content:center;
      border:1px solid rgba(255,255,255,0.25); background: rgba(255,255,255,0.08); cursor:pointer;
      font-size:14px; line-height:1;
    }
    .pellet .name{ font-size:10px; opacity:.9; }
    .minimized .wrap{ display:none; }
    .minimized .pellet{ display:flex; }
    .hdr .icon{ width:26px; height:26px; display:inline-flex; align-items:center; justify-content:center;
      border-radius:10px; border:1px solid rgba(255,255,255,0.2); background: rgba(255,255,255,0.08); cursor:pointer; }
  `);

  // Header
  const header = el("div", {class:"hdr"}, [
    el("div", {class:"dot"}),
    el("div", {class:"title"}, "Circle of Fifths Synth"),
    el("div", {class:"spacer"}),
    el("div", {class:"icon", id:"minBtn", title:"Minimize"}, "–"),
    el("button", {class:"btn power", id:"powerBtn", title:"Audio On/Off"}, "Power")
  ]);

  // Top controls
  const ctrlTop = el("div", {class:"btn-row"}, [
    el("button", {class:"toggle", id:"intervalToggle", title:"Toggle interval mode"}, "Interval"),
    el("select", {id:"intervalSel", title:"Interval"}, Object.keys(INTERVALS).map(k=>el("option",{},k))),
    el("button", {class:"btn", id:"randChord", title:"Random chord"}, "Chord"),
    el("button", {class:"toggle", id:"keyToggle", title:"Toggle key filter"}, "Key"),
    el("select", {id:"keySel", title:"24 Keys"}, [
      el("option", {value:"none"}, "None"),
      ...NAMES.map((_,i)=>el("option",{value:`M:${i}`},`${NAMES[i]} major`)),
      ...NAMES.map((_,i)=>el("option",{value:`m:${i}`},`${NAMES[i]} minor`))
    ])
  ]);

  // Circle + SVG
  const circleWrap = el("div", {class:"circle"});
  const svg = el("svg", {class:"svg", width:String(CIRCLE.size), height:String(CIRCLE.size), viewBox:`0 0 ${CIRCLE.size} ${CIRCLE.size}`});

  // Plasma defs
  const defs = document.createElementNS("http://www.w3.org/2000/svg","defs");
  const grad = document.createElementNS("http://www.w3.org/2000/svg","linearGradient");
  grad.setAttribute("id","plasmaGrad"); grad.setAttribute("x1","0%"); grad.setAttribute("y1","0%"); grad.setAttribute("x2","100%"); grad.setAttribute("y2","0%");
  grad.innerHTML = `<stop offset="0%" stop-color="#0ff" stop-opacity="0.0"/><stop offset="35%" stop-color="#7de3ff" stop-opacity="0.8"/><stop offset="65%" stop-color="#38bdf8" stop-opacity="1.0"/><stop offset="100%" stop-color="#0ff" stop-opacity="0.0"/>`;
  const glow = document.createElementNS("http://www.w3.org/2000/svg","filter");
  glow.setAttribute("id","glow"); glow.innerHTML = `<feGaussianBlur stdDeviation="2" result="b"/><feMerge><feMergeNode in="b"/><feMergeNode in="SourceGraphic"/></feMerge>`;
  const glowWide = document.createElementNS("http://www.w3.org/2000/svg","filter");
  glowWide.setAttribute("id","glowWide"); glowWide.innerHTML = `<feGaussianBlur stdDeviation="5" result="b"/><feMerge><feMergeNode in="b"/><feMergeNode in="SourceGraphic"/></feMerge>`;
  defs.appendChild(grad); defs.appendChild(glow); defs.appendChild(glowWide);
  svg.appendChild(defs);

  const arcLayerBack = document.createElementNS("http://www.w3.org/2000/svg","g"); // halos
  const arcLayerMid  = document.createElementNS("http://www.w3.org/2000/svg","g"); // gradient strand
  const arcLayerFront= document.createElementNS("http://www.w3.org/2000/svg","g"); // core + spark
  svg.appendChild(arcLayerBack); svg.appendChild(arcLayerMid); svg.appendChild(arcLayerFront);
  circleWrap.appendChild(svg);

  // Rotary knobs (with draggable+editable numeric value)
  function makeKnob(labelText, id, {min=0,max=1,step=0.01,value=0,fmt=(v)=>v.toFixed(2)}, onChange){
    const k = el("div",{class:"knob", id});
    const dial = el("div",{class:"dial", title:labelText},[
      el("div",{class:"arc"}),
      el("div",{class:"cap"}),
      el("div",{class:"tick"})
    ]);
    const lab = el("label",{},labelText);
    const val = el("input",{class:"val", value:fmt(value)});
    k.appendChild(dial); k.appendChild(lab); k.appendChild(val);

    const state = { min, max, step, value, prev:value, deg:0 };
    const range = max - min;
    const SWEEP = 270, START = -135;

    function stepClamp(v){
      const s = step || 0.0001;
      return Math.round(v / s) * s;
    }
    function setValue(v, fromUser=false){
      v = stepClamp(clamp(v, min, max));
      state.value = v;
      const t = (v - min)/range;
      const deg = START + SWEEP * t;
      state.deg = deg;
      dial.style.setProperty("--deg", deg + "deg");
      dial.style.setProperty("--pct", (t*100)+"%");
      if (document.activeElement !== val) val.value = fmt(v);
      if (fromUser && typeof onChange === "function") onChange(v);
    }
    setValue(value, false);

    // pointer drag on dial
    let dragging=false;
    const getAngle = (e) => {
      const r = dial.getBoundingClientRect();
      const cx = r.left + r.width/2, cy = r.top + r.height/2;
      const p = e.touches?e.touches[0]:e;
      const x = p.clientX - cx, y = p.clientY - cy;
      let a = Math.atan2(y, x) * 180/Math.PI; a -= 90;
      while (a < -180) a += 360; while (a > 180) a -= 360;
      let rel = clamp(a, START, START+SWEEP);
      const t = (rel - START)/SWEEP; return min + t*range;
    };
    const onDown = e => { dragging=true; e.preventDefault(); setValue(getAngle(e), true); };
    const onMove = e => { if(!dragging) return; e.preventDefault(); setValue(getAngle(e), true); };
    const onUp   = ()=>{ dragging=false; };
    dial.addEventListener("mousedown", onDown);
    window.addEventListener("mousemove", onMove);
    window.addEventListener("mouseup", onUp);
    dial.addEventListener("touchstart", onDown, {passive:false});
    window.addEventListener("touchmove", onMove, {passive:false});
    window.addEventListener("touchend", onUp);

    // wheel fine adjust
    dial.addEventListener("wheel", (e)=>{ e.preventDefault(); const delta = (e.deltaY>0?-1:1)*(step||((max-min)/150)); setValue(state.value + delta, true); }, {passive:false});

    // drag on numeric value (horizontal scrub)
    let dragVal = {drag:false, sx:0, orig:0};
    val.addEventListener("mousedown",(e)=>{ dragVal={drag:true,sx:e.clientX,orig:state.value}; e.preventDefault(); });
    window.addEventListener("mousemove",(e)=>{ if(!dragVal.drag) return; const px = e.clientX - dragVal.sx; const sens = range / 160; setValue(dragVal.orig + px*sens, true); });
    window.addEventListener("mouseup",()=>{ dragVal.drag=false; });

    // manual input with validation
    val.addEventListener("focus", ()=>{ state.prev = state.value; val.select(); });
    val.addEventListener("keydown", (e)=>{ if(e.key==="Enter") val.blur(); if(e.key==="Escape"){ val.value = fmt(state.prev); val.blur(); } });
    val.addEventListener("blur", ()=>{
      const raw = val.value.trim().replace(/[^\-0-9\.]/g,"");
      const num = Number(raw);
      if (!isFinite(num)){ val.value = fmt(state.prev); return; }
      const good = clamp(num, min, max);
      setValue(good, true);
    });

    return {root:k, set:setValue, get:()=>state.value};
  }

  const waveformSel = el("select", {id:"waveSel"}, [
    el("option",{value:"sine"},"Sine"),
    el("option",{value:"square"},"Square"),
    el("option",{value:"sawtooth"},"Saw"),
    el("option",{value:"triangle"},"Triangle")
  ]);

  const knobs = el("div", {class:"knobs"});
  function addKnob(label,id,opts,apply){ const k = makeKnob(label,id,opts,(v)=>apply(v)); knobs.appendChild(k.root); return k; }

  // compact controls fit in 6 columns
  const waveWrap = el("div",{class:"knob"},[
    el("label",{for:"waveSel"},"Wave"),
    waveformSel,
    el("input",{class:"val", value:""})
  ]);
  knobs.appendChild(waveWrap);

  addKnob("Attack","kAttack",{min:0,max:2,step:0.01,value:audio.settings.attack},v=>audio.settings.attack=v);
  addKnob("Decay","kDecay",{min:0,max:2,step:0.01,value:audio.settings.decay},v=>audio.settings.decay=v);
  addKnob("Sustain","kSustain",{min:0,max:1,step:0.01,value:audio.settings.sustain},v=>audio.settings.sustain=v);
  addKnob("Release","kRelease",{min:0,max:4,step:0.01,value:audio.settings.release},v=>audio.settings.release=v);
  addKnob("Cutoff","kCutoff",{min:100,max:12000,step:1,value:audio.settings.cutoff,fmt:v=>Math.round(v)+" Hz"},v=>{audio.settings.cutoff=v; if(audio.filter) audio.filter.frequency.setValueAtTime(v, now());});
  addKnob("Reson.","kRes",{min:0.1,max:20,step:0.1,value:audio.settings.resonance,fmt:v=>v.toFixed(1)},v=>{audio.settings.resonance=v; if(audio.filter) audio.filter.Q.setValueAtTime(v, now());});
  addKnob("Detune","kDetune",{min:-1200,max:1200,step:1,value:audio.settings.detune,fmt:v=>Math.round(v)+" ct"},v=>{audio.settings.detune=v; for(const {osc} of voices.values()) osc.detune.setValueAtTime(v, now());});
  addKnob("Glide","kGlide",{min:0,max:1,step:0.01,value:audio.settings.glide},v=>audio.settings.glide=v);
  addKnob("Volume","kVol",{min:0,max:1,step:0.01,value:audio.settings.volume},v=>{audio.settings.volume=v; if(audio.master) audio.master.gain.setValueAtTime(v, now());});
  addKnob("Delay","kDelay",{min:0,max:1.5,step:0.01,value:audio.settings.delayTime,fmt:v=>v.toFixed(2)+" s"},v=>{audio.settings.delayTime=v; if(audio.delay) audio.delay.delayTime.setValueAtTime(v, now());});
  addKnob("DlyMix","kDelayMix",{min:0,max:1,step:0.01,value:audio.settings.delayMix},v=>{audio.settings.delayMix=v; if(audio.delayGain) audio.delayGain.gain.setValueAtTime(v, now());});
  addKnob("Feedback","kFb",{min:0,max:0.95,step:0.01,value:audio.settings.delayFeedback},v=>{audio.settings.delayFeedback=v; if(audio.delayFeedback) audio.delayFeedback.gain.setValueAtTime(v, now());});
  addKnob("LFO Hz","kLfoRate",{min:0.1,max:20,step:0.1,value:audio.settings.lfoRate},v=>{audio.settings.lfoRate=v; if(audio.lfo) audio.lfo.frequency.setValueAtTime(v, now());});
  addKnob("LFO Amt","kLfoAmt",{min:0,max:1200,step:1,value:audio.settings.lfoAmount,fmt:v=>Math.round(v)},v=>{audio.settings.lfoAmount=v; if(audio.lfoGain) audio.lfoGain.gain.setValueAtTime(v, now());});

  const lfoTargetWrap = el("div",{class:"knob"},[
    el("label",{for:"lfoTarget"},"LFO→"),
    el("select",{id:"lfoTarget"},[ el("option",{value:"pitch"},"Pitch"), el("option",{value:"filter"},"Filter") ]),
    el("input",{class:"val", value:""})
  ]);
  knobs.appendChild(lfoTargetWrap);

  const hints = el("div",{class:"knob"},[
    el("label",{},"Hints"),
    el("input",{class:"val", value:"Hover=play(+interval). Click=sustain. Right-click=remove.", readOnly:true})
  ]);
  knobs.appendChild(hints);

  const body = el("div", {class:"wrap"}, [header, ctrlTop, circleWrap, knobs]);

  // Pellet (minimized state) with mute + expand
  const pellet = el("div",{class:"pellet", id:"pelletBtn", title:"Synth"},[
    el("div",{class:"name"},"Synth"),
    el("div",{class:"row"},[
      el("div",{class:"mini", id:"miniMute", title:"Mute/Unmute"}, "🔊"),
      el("div",{class:"mini", id:"miniOpen", title:"Open"}, "⤢")
    ])
  ]);

  root.appendChild(style);
  root.appendChild(body);
  root.appendChild(pellet);

  // ---------- layout notes ----------
  const center = {x:CIRCLE.size/2, y:CIRCLE.size/2}, radius = CIRCLE.radius;
  const noteButtons = new Map();
  function posFor(idx){
    const angle = (-90 + idx * 30) * Math.PI / 180;
    return { x: center.x + radius * Math.cos(angle), y: center.y + radius * Math.sin(angle) };
  }
  for (let i=0;i<12;i++){
    const pc = FIFTHS[i]; const p = posFor(i);
    const btn = el("div",{
      class:"note",
      style:{ left:(p.x-NOTE_DIAM/2)+"px", top:(p.y-NOTE_DIAM/2)+"px" },
      title:`${NAMES[pc]} — hover(+interval), click=sustain, right-click=remove`
    }, NAMES[pc]);

    // HOVER (melody + interval)
    btn.addEventListener("mouseenter", () => {
      if (!audio.started || audio.muted) return;
      if (!isNoteAllowed(pc)) return;
      let oct = 4;
      const set = sustained.get(pc);
      if (set && set.size){
        const last = lastAlt.get(pc) || "down";
        const dir = last === "down" ? "up" : "down"; lastAlt.set(pc, dir);
        oct = dir === "up" ? Math.min(6, (Math.max(...set) || 4) + 1)
                           : Math.max(2, (Math.min(...set) || 4) - 1);
      }
      hoverPlay(pc, oct);
      if (intervalToggle.classList.contains("on")){
        const iv = INTERVALS[intervalSel.value] || 0;
        const pc2 = PC(pc + iv);
        if (isNoteAllowed(pc2)) hoverPlay(pc2, oct);
      }
    });

    // CLICK (sustain + interval)
    btn.addEventListener("click", e => {
      e.preventDefault();
      if (!audio.started) { resumeAudio(); powerBtn.classList.add("on"); }
      if (!isNoteAllowed(pc)) return;
      const addRoot = () => startSustain(pc, (sustained.get(pc)?.size ? pickNextOctave(pc) : 4));
      if (intervalToggle.classList.contains("on")){
        addRoot(); const iv = INTERVALS[intervalSel.value] || 0; const pc2 = PC(pc + iv);
        if (isNoteAllowed(pc2)) startSustain(pc2, 4);
      } else { addRoot(); }
      updateNoteStates(); syncArcs();
    });

    btn.addEventListener("contextmenu", e => { e.preventDefault(); stopSustainNote(pc); updateNoteStates(); });

    circleWrap.appendChild(btn); noteButtons.set(pc, btn);
  }

  // ---------- REALISTIC PLASMA ARCS ----------
  // Multi-strand jitter (turbulence), tapered ends, flowing gradient, moving spark.
  // Brightness and thickness react to audio energy.
  const arcMap = new Map(); // "a-b" -> {back, mid, front, spark, seed}
  let animRAF = null, ampSmooth = 0.2;

  const fract = v => v - Math.floor(v);
  function noise1(x){ return fract(Math.sin(x*12.9898)*43758.5453); }
  function sCurve(t){ return Math.pow(Math.sin(Math.PI*t), 1.35); }

  function keyPair(a,b){ return a<b ? `${a}-${b}` : `${b}-${a}`; }
  function activePCs(){ return [...sustained.keys()]; }
  function posOfPC(pc){ const idx = FIFTHS.indexOf(pc); return posFor(idx); }

  function ensureArc(a,b){
    const k = keyPair(a,b);
    if (arcMap.has(k)) return arcMap.get(k);

    const makePath = (stroke, width, opacity, filter, useGrad=false) => {
      const p = document.createElementNS("http://www.w3.org/2000/svg","path");
      p.setAttribute("fill","none");
      p.setAttribute("stroke", stroke);
      p.setAttribute("stroke-width", String(width));
      p.setAttribute("stroke-linecap","round");
      p.setAttribute("opacity", String(opacity));
      if (filter) p.setAttribute("filter", filter);
      if (useGrad) p.setAttribute("stroke","url(#plasmaGrad)");
      p.setAttribute("stroke-dasharray","6 10"); // flow illusion
      return p;
    };

    const back = makePath("#7de3ff", 7, 0.30, "url(#glowWide)", false);
    const mid  = makePath("url(#plasmaGrad)", 3.2, 0.95, "url(#glow)", true);
    const front= makePath("#38bdf8", 2.0, 0.90, "url(#glow)", false);

    arcLayerBack.appendChild(back);
    arcLayerMid.appendChild(mid);
    arcLayerFront.appendChild(front);

    const spark = document.createElementNS("http://www.w3.org/2000/svg","circle");
    spark.setAttribute("r","2.8");
    spark.setAttribute("fill","#e0faff");
    spark.setAttribute("filter","url(#glow)");
    arcLayerFront.appendChild(spark);

    const entry = {back, mid, front, spark, seed: Math.random()*1000};
    arcMap.set(k, entry);
    return entry;
  }

  function clearStaleArcs(){
    const need = new Set();
    const pcs = activePCs();
    for (let i=0;i<pcs.length;i++) for (let j=i+1;j<pcs.length;j++) need.add(keyPair(pcs[i],pcs[j]));
    for (const k of [...arcMap.keys()]){
      if (!need.has(k)){
        const {back,mid,front,spark} = arcMap.get(k);
        back.remove(); mid.remove(); front.remove(); spark.remove();
        arcMap.delete(k);
      }
    }
  }
  function syncArcs(){ clearStaleArcs(); } // geometry updates in animate()

  // anchor arcs to the button ring edge
  function anchorPoints(pa, pb){
    const r = NOTE_DIAM/2 - 2;
    const dx = pb.x - pa.x, dy = pb.y - pa.y;
    const d = Math.hypot(dx,dy) || 1;
    const ux = dx/d, uy = dy/d;
    return [{x: pa.x + ux*r, y: pa.y + uy*r}, {x: pb.x - ux*r, y: pb.y - uy*r}, d];
  }

  function buildPath(pa,pb,time,seed,strand=0){
    let [a,b,dist] = anchorPoints(pa,pb);
    const dx = b.x - a.x, dy = b.y - a.y;
    const nx = -dy / (dist||1), ny = dx / (dist||1); // normal

    const segs = Math.max(22, Math.floor(dist/8));
    const baseAmp = Math.min(20, 9 + dist*0.03) * (1 + 0.12*strand);
    const speed = 0.7 + 0.18*strand;

    let d = `M ${a.x.toFixed(2)} ${a.y.toFixed(2)}`;
    for (let i=1;i<=segs;i++){
      const t = i/segs;
      const px = a.x + dx*t, py = a.y + dy*t;

      // layered noise turbulence
      const n1 = noise1((t*2.7 + time*speed) + seed);
      const n2 = noise1((t*6.9 - time*speed*0.6) + seed*0.37);
      const n3 = noise1((t*12.3 + time*speed*1.2) + seed*1.13);
      const jitter = (n1-0.5)*0.7 + (n2-0.5)*0.5 + (n3-0.5)*0.25;

      // tapered amplitude (damped near ends)
      const amp = baseAmp * sCurve(t);

      // subtle bow toward center (electrostatic pull)
      const bow = (0.5 - Math.abs(0.5 - t)) * 0.65;

      const ox = nx * (jitter * amp + bow * 6);
      const oy = ny * (jitter * amp + bow * 6);

      d += ` L ${(px+ox).toFixed(2)} ${(py+oy).toFixed(2)}`;
    }
    return d;
  }

  function getAudioEnergy(){
    if (!audio.analyser) return 0.2;
    const A = audio.analyser;
    const buf = new Uint8Array(A.fftSize);
    A.getByteTimeDomainData(buf);
    let sum = 0;
    for (let i=0;i<buf.length;i++){ const v = (buf[i]-128)/128; sum += v*v; }
    const rms = Math.sqrt(sum / buf.length); // 0..1
    return clamp(rms*2.2, 0, 1); // boost a bit
  }

  function animate(){
    const t = performance.now()/1000;
    // audio -> arc brightness
    const energy = getAudioEnergy();
    ampSmooth = ampSmooth*0.9 + energy*0.1;

    const pcs = activePCs();
    if (pcs.length >= 2){
      for (let i=0;i<pcs.length;i++){
        for (let j=i+1;j<pcs.length;j++){
          const a = pcs[i], b = pcs[j];
          const entry = ensureArc(a,b);
          const pa = posOfPC(a), pb = posOfPC(b);

          // three strands blended
          const d0 = buildPath(pa,pb,t,entry.seed,0);
          const d1 = buildPath(pa,pb,t+0.11,entry.seed+10,1);
          const d2 = buildPath(pa,pb,t+0.23,entry.seed+20,2);

          entry.back.setAttribute("d", d1);
          entry.mid.setAttribute("d", d0);
          entry.front.setAttribute("d", d2);

          // responsive thickness/opacity
          const k = 0.6 + 0.8*ampSmooth;
          entry.back.setAttribute("stroke-width", String(6.5 * k));
          entry.front.setAttribute("stroke-width", String(1.8 * k));
          const flick = 0.85 + 0.15*Math.abs(Math.sin((t+entry.seed)*1.4));
          entry.back.setAttribute("opacity", String(0.22 + 0.20*flick));
          entry.front.setAttribute("opacity", String(0.78 + 0.22*flick));

          // flowing effect via dash offset
          const baseFlow = 80 + 40*Math.sin((t+entry.seed)*0.6);
          entry.mid.style.strokeDashoffset  = String(-(t*baseFlow)%1000);
          entry.front.style.strokeDashoffset= String(-((t*baseFlow*1.2)+25)%1000);

          // spark travels along core
          const pathNode = entry.front;
          const len = pathNode.getTotalLength ? pathNode.getTotalLength() : 0;
          const sPos = ( (t*0.5 + entry.seed) % 1 ) * (len||1);
          if (len){
            const pt = pathNode.getPointAtLength(sPos);
            entry.spark.setAttribute("cx", pt.x);
            entry.spark.setAttribute("cy", pt.y);
            const sGlow = 0.8 + 0.2*Math.sin((t+entry.seed)*3.1);
            entry.spark.setAttribute("r", String(2.2 + 1.2*sGlow));
          }
        }
      }
    }
    animRAF = requestAnimationFrame(animate);
  }
  animRAF = requestAnimationFrame(animate);

  function updateNoteStates(){
    // reset all
    for (const [pc, btn] of noteButtons){
      btn.classList.remove("home");
      const on = sustained.has(pc);
      btn.classList.toggle("active", on);
      btn.classList.toggle("inactive", !isNoteAllowed(pc));
    }
    // mark root when key mode on
    const homePC = getHomePC();
    if (homePC != null){
      const btn = noteButtons.get(homePC);
      if (btn) btn.classList.add("home");
    }
  }

  // ---------- controls ----------
  const powerBtn = header.querySelector("#powerBtn");
  powerBtn.addEventListener("click", () => {
    if (!audio.started || audio.muted) { resumeAudio(); powerBtn.classList.add("on"); }
    else { suspendAudio(); powerBtn.classList.remove("on"); }
  });

  const intervalToggle = ctrlTop.querySelector("#intervalToggle");
  const intervalSel = ctrlTop.querySelector("#intervalSel");
  intervalToggle.addEventListener("click", () => intervalToggle.classList.toggle("on"));

  const keyToggle = ctrlTop.querySelector("#keyToggle");
  const keySel = ctrlTop.querySelector("#keySel");
  keyToggle.addEventListener("click", () => { keyToggle.classList.toggle("on"); updateNoteStates(); });
  keySel.addEventListener("change", updateNoteStates);

  function isNoteAllowed(pc){
    if (!keyToggle.classList.contains("on")) return true;
    const v = keySel.value; if (v==="none") return true;
    const [mode, rootIdxStr] = v.split(":"); const rootIdx = parseInt(rootIdxStr,10);
    const scale = mode === "M" ? MAJOR : MINOR;
    return scale.map(s=>PC(rootIdx+s)).includes(pc);
  }
  function getHomePC(){
    if (!keyToggle.classList.contains("on")) return null;
    const v = keySel.value; if (v==="none") return null;
    const [_, rootIdxStr] = v.split(":"); return parseInt(rootIdxStr,10);
  }

  // random chord
  const randBtn = ctrlTop.querySelector("#randChord");
  randBtn.addEventListener("click", () => {
    const current = [...sustained.keys()]; const count = current.length; if (!count) return;
    stopAllSustain();
    const pool = []; for (let pc=0; pc<12; pc++) if (isNoteAllowed(pc)) pool.push(pc);
    if (!pool.length) return;
    const chosen = new Set();
    while (chosen.size < Math.min(count, pool.length)) chosen.add(pool[Math.floor(Math.random()*pool.length)]);
    for (const pc of chosen) startSustain(pc, 4);
    updateNoteStates(); syncArcs();
  });

  // drag to move
  (() => {
    let dragging=false,sx=0,sy=0,bx=0,by=0;
    header.addEventListener("mousedown", e => { dragging=true; sx=e.clientX; sy=e.clientY;
      const r = host.getBoundingClientRect(); bx=r.right; by=r.bottom; header.style.cursor="grabbing"; e.preventDefault();
    });
    window.addEventListener("mousemove", e => {
      if (!dragging) return; const dx=e.clientX-sx, dy=e.clientY-sy;
      host.style.right = (document.documentElement.clientWidth - bx - dx) + "px";
      host.style.bottom = (document.documentElement.clientHeight - by - dy) + "px";
    });
    window.addEventListener("mouseup", ()=>{ dragging=false; header.style.cursor="grab"; });
  })();

  // LFO target + waveform
  const lfoTargetSel = lfoTargetWrap.querySelector("#lfoTarget");
  lfoTargetSel.addEventListener("change", ()=>{ audio.lfoTarget=lfoTargetSel.value; for (const v of voices.values()) attachLFOToVoice(v); });
  waveformSel.addEventListener("change", ()=>{ audio.settings.waveform = waveformSel.value; });

  // Minimize / pellet
  const minBtn = header.querySelector("#minBtn");
  const pelletBtn = pellet;
  const miniMute = pellet.querySelector("#miniMute");
  const miniOpen = pellet.querySelector("#miniOpen");
  const orig = {w: SIZE.w, h: SIZE.h};
  let minimized = false;

  function setMinimized(v){
    minimized = v;
    if (v){ host.classList.add("minimized"); host.style.width = "80px"; host.style.height = "80px"; }
    else   { host.classList.remove("minimized"); host.style.width = orig.w+"px"; host.style.height = orig.h+"px"; }
  }
  function updatePelletIcons(){
    if (!audio.started || audio.muted) miniMute.textContent = "🔇";
    else miniMute.textContent = "🔊";
  }

  minBtn.addEventListener("click", ()=> setMinimized(true));
  miniOpen.addEventListener("click", (e)=>{ e.stopPropagation(); setMinimized(false); });
  miniMute.addEventListener("click", (e)=>{
    e.stopPropagation();
    if (!audio.started || audio.muted){ resumeAudio(); powerBtn.classList.add("on"); }
    else { suspendAudio(); powerBtn.classList.remove("on"); }
  });
  pelletBtn.addEventListener("click", ()=> setMinimized(false)); // click space to expand

  // start audio on first pointer inside widget
  root.addEventListener("pointerdown", () => { if (!audio.started){ resumeAudio(); powerBtn.classList.add("on"); } }, {once:false});

  // initial paint
  function placeNotes(){ for(const [pc,btn] of noteButtons){ const idx=FIFTHS.indexOf(pc); const p=posFor(idx); btn.style.left=(p.x-NOTE_DIAM/2)+"px"; btn.style.top=(p.y-NOTE_DIAM/2)+"px"; } }
  function refresh(){ placeNotes(); updateNoteStates(); syncArcs(); }
  refresh();
})();
</script>



</body>
</html>