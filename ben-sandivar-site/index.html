<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Ben Sandivar — Transforming Thought into Form</title>

  <!-- Favicons -->
  <link rel="icon" type="image/png" href="https://raw.githubusercontent.com/BenS-UI/portfolio/cfc0bc646dc8f7cb21379d516f1b1ca0c0f85e06/B-logo-a.svg" />
  <link rel="shortcut icon" href="https://raw.githubusercontent.com/BenS-UI/portfolio/cfc0bc646dc8f7cb21379d516f1b1ca0c0f85e06/B-logo-a.svg" type="image/png" />

  <!-- Fonts & Icons -->
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Gabarito:wght@400;700;900&family=Geologica:wght@300;400;500;700&display=swap" rel="stylesheet" />
  <link href="https://fonts.googleapis.com/icon?family=Material+Symbols+Outlined" rel="stylesheet" />

  <!-- Core libs -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js" defer></script>

  <!-- Site styles -->
</head>
    <link rel="stylesheet" href="css/reset.css">
    <link rel="stylesheet" href="css/base.css">
    <link rel="stylesheet" href="css/cursor.css">
    <link rel="stylesheet" href="css/page-header.css">
    <link rel="stylesheet" href="css/navbar.css">
    <link rel="stylesheet" href="css/hero.css">
    <link rel="stylesheet" href="css/bucket-hero.css">
    <link rel="stylesheet" href="css/video-hero.css">
    <link rel="stylesheet" href="css/photo-grid.css">
    <link rel="stylesheet" href="css/projects.css">
    <link rel="stylesheet" href="css/music.css">
    <link rel="stylesheet" href="css/contact.css">
    <link rel="stylesheet" href="css/about.css">
    <link rel="stylesheet" href="css/skills.css">
    <link rel="stylesheet" href="css/footer.css">
    <link rel="stylesheet" href="css/themes.css">
    <link rel="stylesheet" href="css/containers.css">
    <link rel="stylesheet" href="css/992.css">
    <link rel="stylesheet" href="css/768.css">
    <script src="js/theme-toggle.js" defer></script>

<body>
  <!-- Slots for fetched sections -->
  <div id="navbar-slot"></div>
  <div id="hero-slot"></div>
  <div id="bucket-slot"></div>
  <div id="gallery-slot"></div>
  <div id="projects-slot"></div>
  <div id="music-slot"></div>
  <div id="about-slot"></div>
  <div id="skills-slot"></div>
  <div id="iwrite-slot"></div>
  <div id="contact-slot"></div>
  <div id="footer-slot"></div>

  <!-- Anything not extracted stays here -->
  <div class="theme-toggle-container">
    <button id="theme-toggle">
      <span class="material-symbols-outlined theme-icon">dark_mode</span>
    </button>
  </div>

  <!-- Vendor util + site script -->
  <script src="https://cdn.jsdelivr.net/npm/vanilla-tilt@1.8.1/dist/vanilla-tilt.min.js" defer></script>
  <script src="scripts.js" defer></script>

  <!-- Fragment loader: fetches HTML and executes any inline scripts inside it -->
  <script>
    (function () {
      const parts = [
        { slot: '#navbar-slot',  path: 'homesplits/navbar.html' },
        { slot: '#hero-slot',    path: 'homesplits/hero.html' },
        { slot: '#bucket-slot',  path: 'homesplits/bucket.html' },
        { slot: '#gallery-slot', path: 'homesplits/gallery.html' },
        { slot: '#projects-slot',path: 'homesplits/projects.html' },
        { slot: '#music-slot',   path: 'homesplits/music.html' },
        { slot: '#about-slot',   path: 'homesplits/about.html' },
        { slot: '#skills-slot',  path: 'homesplits/skills.html' },
        { slot: '#iwrite-slot',  path: 'homesplits/iwrite.html' },
        { slot: '#contact-slot', path: 'homesplits/contact.html' },
        { slot: '#footer-slot', path: 'homesplits/footer.html' }
      ];

      const fetchText = (url) => fetch(url, { cache: 'no-store' }).then(r => {
        if (!r.ok) throw new Error('HTTP ' + r.status + ' for ' + url);
        return r.text();
      });

      function injectWithScripts(targetEl, html, baseURL) {
        const tpl = document.createElement('template');
        tpl.innerHTML = html;

        // Execute scripts found in fragment (inline or with src)
        const scripts = tpl.content.querySelectorAll('script');
        scripts.forEach(old => {
          const s = document.createElement('script');
          // Copy attributes and fix relative src to fragment base
          for (const { name, value } of Array.from(old.attributes)) {
            if (name === 'src') {
              try { s.src = new URL(value, baseURL).href; } catch { s.src = value; }
            } else {
              s.setAttribute(name, value);
            }
          }
          if (old.textContent) s.textContent = old.textContent;
          old.replaceWith(s);
        });

        targetEl.innerHTML = '';
        targetEl.appendChild(tpl.content.cloneNode(true));
      }

      Promise.all(parts.map(async ({ slot, path }) => {
        const host = document.querySelector(slot);
        if (!host) return;
        try {
          const base = new URL(path, window.location.href);
          const html = await fetchText(base);
          injectWithScripts(host, html, base);
        } catch (err) {
          console.error('Failed to load', path, err);
        }
      })).then(() => {
        // Signal that all fragments are mounted (useful if scripts.js wants to hook)
        window.dispatchEvent(new Event('components:mounted'));
      });
    })();
  </script>





<!-- Circle of Fifths Synth Widget — v2 -->
<script>
(() => {
  const WIDGET_ID = "circle-fifths-synth-widget";
  if (document.getElementById(WIDGET_ID)) return;

  // ---------- helpers ----------
  const el = (tag, attrs = {}, children = []) => {
    const n = document.createElement(tag);
    for (const [k, v] of Object.entries(attrs)) {
      if (k === "style") Object.assign(n.style, v);
      else if (k === "class") n.className = v;
      else if (k.startsWith("on") && typeof v === "function") n.addEventListener(k.slice(2), v);
      else n.setAttribute(k, v);
    }
    for (const c of (Array.isArray(children) ? children : [children])) {
      if (c == null) continue;
      n.appendChild(typeof c === "string" ? document.createTextNode(c) : c);
    }
    return n;
  };
  const clamp = (v, a, b) => Math.min(Math.max(v, a), b);
  const midiToHz = m => 440 * Math.pow(2, (m - 69) / 12);
  const PC = n => ((n % 12) + 12) % 12;

  // ---------- pitch / theory ----------
  const NAMES = ["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"];
  const FIFTHS = [0,7,2,9,4,11,6,1,8,3,10,5];
  const MAJOR = [0,2,4,5,7,9,11];
  const MINOR = [0,2,3,5,7,8,10];
  const INTERVALS = { "m3":3,"M3":4,"P5":7,"m7":10,"M7":11,"P8":12,"M9":14,"P11":17 };

  // ---------- audio ----------
  const audio = {
    ctx:null, master:null, dryGain:null, filter:null, pan:null,
    delay:null, delayGain:null, delayFeedback:null,
    lfo:null, lfoGain:null, lfoTarget:"pitch", started:false,
    settings:{
      waveform:"sine", attack:0.01, decay:0.15, sustain:0.6, release:0.4,
      cutoff:8000, resonance:0.7, detune:0, glide:0.0, volume:0.75,
      delayTime:0.18, delayMix:0.25, delayFeedback:0.28, lfoRate:5, lfoAmount:0
    }
  };
  const now = () => (audio.ctx ? audio.ctx.currentTime : 0);

  function initAudio(){
    if (audio.ctx) return;
    const AC = window.AudioContext || window.webkitAudioContext;
    audio.ctx = new AC();
    const ctx = audio.ctx;

    audio.master = ctx.createGain(); audio.master.gain.value = audio.settings.volume;
    audio.dryGain = ctx.createGain(); audio.dryGain.gain.value = 1;

    audio.filter = ctx.createBiquadFilter();
    audio.filter.type = "lowpass";
    audio.filter.frequency.value = audio.settings.cutoff;
    audio.filter.Q.value = audio.settings.resonance;

    audio.pan = ctx.createStereoPanner();

    audio.delay = ctx.createDelay(1.5);
    audio.delay.delayTime.value = audio.settings.delayTime;
    audio.delayGain = ctx.createGain(); audio.delayGain.gain.value = audio.settings.delayMix;
    audio.delayFeedback = ctx.createGain(); audio.delayFeedback.gain.value = audio.settings.delayFeedback;
    audio.delay.connect(audio.delayFeedback); audio.delayFeedback.connect(audio.delay);
    audio.delay.connect(audio.delayGain);

    audio.lfo = ctx.createOscillator(); audio.lfo.type="sine"; audio.lfo.frequency.value=audio.settings.lfoRate;
    audio.lfoGain = ctx.createGain(); audio.lfoGain.gain.value = audio.settings.lfoAmount;
    audio.lfo.connect(audio.lfoGain);
    audio.lfo.start();

    // mix
    audio.dryGain.connect(audio.filter);
    audio.delayGain.connect(audio.filter);
    audio.filter.connect(audio.pan);
    audio.pan.connect(audio.master);
    audio.master.connect(ctx.destination);
  }
  function resumeAudio(){ initAudio(); if(audio.ctx.state!=="running") audio.ctx.resume(); audio.started=true; }

  // voice state
  const sustained = new Map();   // pc -> Set(oct)
  const voices = new Map();      // `${pc}:${oct}` -> nodes
  const hoverNotes = new Set();  // temp voices keys
  const lastAlt = new Map();     // pc -> "up"|"down"

  function attachLFOToVoice(v){
    if (!audio.lfo || !audio.lfoGain) return;
    audio.lfoGain.disconnect();
    if (audio.lfoTarget === "pitch") audio.lfoGain.connect(v.osc.detune);
    else audio.lfoGain.connect(audio.filter.frequency);
  }

  function createVoice(pc, octave, {ephemeral=false}={}){
    const ctx = audio.ctx;
    const osc = ctx.createOscillator();
    const amp = ctx.createGain();
    osc.type = audio.settings.waveform;
    osc.detune.value = audio.settings.detune;

    const midi = 12*(octave+1)+pc;
    const freq = midiToHz(midi);

    const glide = clamp(audio.settings.glide, 0, 1);
    if (glide>0 && voices.size){
      let sum=0,n=0;
      for(const k of voices.keys()){ const [spc,so]=k.split(":").map(Number); sum += 12*(so+1)+spc; n++; }
      const fromHz = midiToHz(sum/n);
      osc.frequency.setValueAtTime(fromHz, ctx.currentTime);
      osc.frequency.exponentialRampToValueAtTime(freq, ctx.currentTime + glide);
    } else {
      osc.frequency.setValueAtTime(freq, ctx.currentTime);
    }

    // ADSR
    const t0 = ctx.currentTime;
    const A = clamp(audio.settings.attack, 0.001, 2);
    const D = clamp(audio.settings.decay, 0, 2);
    const S = clamp(audio.settings.sustain, 0, 1);
    const R = clamp(audio.settings.release, 0.02, 4);
    amp.gain.cancelScheduledValues(t0);
    amp.gain.setValueAtTime(0.0001, t0);
    amp.gain.exponentialRampToValueAtTime(1.0, t0 + A);
    amp.gain.exponentialRampToValueAtTime(Math.max(S,0.0001), t0 + A + D);

    osc.connect(amp); amp.connect(audio.dryGain); amp.connect(audio.delay);
    attachLFOToVoice({osc});
    osc.start();

    const key = `${pc}:${octave}`;
    const pack = {osc, amp, key, release: () => {
      const t = ctx.currentTime;
      amp.gain.cancelScheduledValues(t);
      amp.gain.setValueAtTime(amp.gain.value, t);
      amp.gain.exponentialRampToValueAtTime(0.0001, t + R);
      setTimeout(()=>{ try{osc.stop()}catch{}; try{osc.disconnect()}catch{}; try{amp.disconnect()}catch{}; }, (R+0.05)*1000);
    }};
    if (!ephemeral) voices.set(key, pack);
    return pack;
  }

  function startSustain(pc, octave){
    const set = sustained.get(pc) || new Set();
    if (!set.has(octave)){
      set.add(octave); sustained.set(pc,set);
      createVoice(pc, octave, {ephemeral:false});
      syncArcs();
    }
  }
  function stopSustainNote(pc){
    const set = sustained.get(pc); if(!set) return;
    for(const oct of set){ const k=`${pc}:${oct}`; const v=voices.get(k); if(v){v.release(); voices.delete(k);} }
    sustained.delete(pc);
    syncArcs();
  }
  function stopAllSustain(){
    for (const v of voices.values()) v.release();
    voices.clear(); sustained.clear(); syncArcs();
  }
  function hoverPlay(pc, octave, dur=0.35){
    const v = createVoice(pc, octave, {ephemeral:true});
    const key = `h:${pc}:${octave}:${Math.random().toString(36).slice(2)}`;
    hoverNotes.add(key); setTimeout(()=>{ v.release(); hoverNotes.delete(key); }, dur*1000);
  }
  function pickNextOctave(pc){
    const set = sustained.get(pc) || new Set();
    const order = [4,5,3,6,2];
    for (const o of order) if (!set.has(o)) return o;
    let o=4; while(set.has(o)) o++; return clamp(o,1,7);
  }

  // ---------- UI (Shadow DOM) ----------
  const SIZE = { w: 620, h: 680 };     // bigger window
  const CIRCLE = { size: 340, radius: 135 };

  const host = el("div", { id: WIDGET_ID });
  Object.assign(host.style, {
    position:"fixed", right:"24px", bottom:"24px",
    width: SIZE.w+"px", height: SIZE.h+"px", zIndex: 2147483000
  });
  document.body.appendChild(host);
  const root = host.attachShadow({mode:"open"});

  const style = el("style", {}, `
  :host { all: initial; }
  * { box-sizing: border-box; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial; }
  .wrap {
    position: relative; width: 100%; height: 100%;
    display: grid; grid-template-rows: auto auto 1fr auto;
    border-radius: 18px;
    /* Darker glass for white pages */
    background: rgba(15,18,22,0.45);
    box-shadow: 0 18px 40px rgba(0,0,0,0.45), inset 0 1px 0 rgba(255,255,255,0.12);
    backdrop-filter: blur(16px) saturate(140%);
    border: 1px solid rgba(255,255,255,0.22);
    color: #f0fbff;
    overflow: hidden;
  }
  .hdr {
    display:flex; align-items:center; gap:10px; padding:10px 12px; cursor:grab; user-select:none;
    background: linear-gradient(180deg, rgba(255,255,255,0.10), rgba(255,255,255,0.05));
  }
  .dot { width:10px; height:10px; border-radius:50%; background:#22d3ee; box-shadow:0 0 10px #22d3ee; }
  .title { font-weight:600; font-size:14px; color:#eaffff; letter-spacing:0.2px; }
  .btn, .toggle {
    font-size:12px; color:#eaffff; background: rgba(255,255,255,0.08);
    border:1px solid rgba(255,255,255,0.24); padding:6px 10px; border-radius:12px;
    backdrop-filter: blur(6px); cursor:pointer; transition: transform .06s ease, background .2s ease;
  }
  .btn:active, .toggle:active { transform: scale(0.98); }
  .btn-row { display:flex; gap:8px; align-items:center; padding:8px 12px; flex-wrap:wrap; }
  .circle { position: relative; width:${CIRCLE.size}px; height:${CIRCLE.size}px; margin: 8px auto 0; }
  .note {
    position:absolute; width:52px; height:52px; border-radius:50%;
    display:flex; align-items:center; justify-content:center;
    color:#eaffff; font-weight:700; font-size:13px; letter-spacing:0.4px;
    background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.28), rgba(255,255,255,0.10));
    border:1px solid rgba(255,255,255,0.28);
    box-shadow: inset 0 2px 8px rgba(255,255,255,0.18), 0 0 0 2px rgba(255,255,255,0.06);
    transition: transform .08s ease, box-shadow .2s ease, opacity .2s ease;
    user-select:none;
  }
  .note:hover { transform: scale(1.06); }
  .inactive { opacity: 0.25; pointer-events: none; }
  .active { box-shadow: inset 0 2px 8px rgba(255,255,255,0.18), 0 0 16px 2px rgba(56,189,248,0.9); }
  .svg { position:absolute; inset:0; pointer-events:none; mix-blend-mode: screen; }
  .knobs {
    display:grid; grid-template-columns: repeat(6, 1fr); gap:10px; padding:10px 12px 14px;
  }
  .knob { display:flex; flex-direction:column; gap:4px; }
  label { font-size:11px; color:#eaffff; opacity:0.9; }
  input[type=range] { width:100%; }
  /* Black dropdowns for contrast */
  select {
    width:100%; padding:6px 8px; border-radius:10px;
    border:1px solid rgba(255,255,255,0.28);
    background: #000; color:#fff; font-size:12px;
  }
  .row { display:flex; gap:8px; align-items:center; }
  .spacer { flex:1; }
  .power.on { background: linear-gradient(180deg, rgba(34,211,238,0.6), rgba(59,130,246,0.45)); }
  .small { font-size:11px; color:#e7faff; opacity:0.85; }
  `);

  // Header
  const header = el("div", {class:"hdr"}, [
    el("div", {class:"dot"}),
    el("div", {class:"title"}, "Circle of Fifths Synth"),
    el("div", {class:"spacer"}),
    el("button", {class:"btn power", id:"powerBtn", title:"Audio On/Off"}, "Power")
  ]);

  // Controls row
  const ctrlTop = el("div", {class:"btn-row"}, [
    el("button", {class:"toggle", id:"intervalToggle", title:"Toggle interval mode"}, "Interval"),
    el("select", {id:"intervalSel", title:"Interval"}, Object.keys(INTERVALS).map(k=>el("option",{},k))),
    el("button", {class:"btn", id:"randChord", title:"Random chord"}, "Chord"),
    el("button", {class:"toggle", id:"keyToggle", title:"Toggle key filter"}, "Key"),
    el("select", {id:"keySel", title:"24 Keys"}, [
      el("option", {value:"none"}, "None"),
      ...NAMES.map((_,i)=>el("option",{value:`M:${i}`},`${NAMES[i]} major`)),
      ...NAMES.map((_,i)=>el("option",{value:`m:${i}`},`${NAMES[i]} minor`))
    ])
  ]);

  // Circle + SVG
  const circleWrap = el("div", {class:"circle"});
  const svg = el("svg", {class:"svg", width: String(CIRCLE.size), height:String(CIRCLE.size), viewBox:`0 0 ${CIRCLE.size} ${CIRCLE.size}`});
  // defs for plasma glow
  const defs = document.createElementNS("http://www.w3.org/2000/svg","defs");
  const glow = document.createElementNS("http://www.w3.org/2000/svg","filter");
  glow.setAttribute("id","glow");
  glow.innerHTML = `
    <feGaussianBlur stdDeviation="3" result="blur"/>
    <feMerge>
      <feMergeNode in="blur"/>
      <feMergeNode in="SourceGraphic"/>
    </feMerge>`;
  const glowWide = document.createElementNS("http://www.w3.org/2000/svg","filter");
  glowWide.setAttribute("id","glowWide");
  glowWide.innerHTML = `<feGaussianBlur stdDeviation="6" result="b"/><feMerge><feMergeNode in="b"/><feMergeNode in="SourceGraphic"/></feMerge>`;
  defs.appendChild(glow); defs.appendChild(glowWide);
  svg.appendChild(defs);
  const arcLayerBack = document.createElementNS("http://www.w3.org/2000/svg","g"); // soft halo
  const arcLayerFront = document.createElementNS("http://www.w3.org/2000/svg","g"); // bright core
  svg.appendChild(arcLayerBack); svg.appendChild(arcLayerFront);
  circleWrap.appendChild(svg);

  // Knobs
  const knob = (labelText, id, min, max, step, val) =>
    el("div", {class:"knob"}, [ el("label",{for:id},labelText), el("input",{type:"range",id,min,max,step,value:val}) ]);

  const waveformSel = el("select", {id:"waveSel"}, [
    el("option",{value:"sine"},"Sine"),
    el("option",{value:"square"},"Square"),
    el("option",{value:"sawtooth"},"Saw"),
    el("option",{value:"triangle"},"Triangle")
  ]);

  const knobs = el("div", {class:"knobs"}, [
    el("div",{class:"knob"}, [el("label",{for:"waveSel"},"Wave"), waveformSel]),
    knob("Attack","kAttack",0,2,0.01,audio.settings.attack),
    knob("Decay","kDecay",0,2,0.01,audio.settings.decay),
    knob("Sustain","kSustain",0,1,0.01,audio.settings.sustain),
    knob("Release","kRelease",0,4,0.01,audio.settings.release),
    knob("Cutoff","kCutoff",100,12000,1,audio.settings.cutoff),
    knob("Reson.","kRes",0.1,20,0.1,audio.settings.resonance),
    knob("Detune","kDetune",-1200,1200,1,audio.settings.detune),
    knob("Glide","kGlide",0,1,0.01,audio.settings.glide),
    knob("Volume","kVol",0,1,0.01,audio.settings.volume),
    knob("Delay","kDelay",0,1.5,0.01,audio.settings.delayTime),
    knob("DlyMix","kDelayMix",0,1,0.01,audio.settings.delayMix),
    knob("Feedback","kFb",0,0.95,0.01,audio.settings.delayFeedback),
    knob("LFO Hz","kLfoRate",0.1,20,0.1,audio.settings.lfoRate),
    knob("LFO Amt","kLfoAmt",0,1200,1,audio.settings.lfoAmount),
    el("div",{class:"knob"}, [el("label",{for:"lfoTarget"},"LFO→"), el("select",{id:"lfoTarget"},[
      el("option",{value:"pitch"},"Pitch"),
      el("option",{value:"filter"},"Filter")
    ])]),
    el("div",{class:"knob"}, [el("label",{},"Hints"), el("div",{class:"small"},"Hover = play. Interval adds harmony. Click = sustain. Right-click = remove.")])
  ]);

  const body = el("div", {class:"wrap"}, [header, ctrlTop, circleWrap, knobs]);
  root.appendChild(style); root.appendChild(body);

  // ---------- note layout ----------
  const center = {x:CIRCLE.size/2, y:CIRCLE.size/2}, radius = CIRCLE.radius;
  const noteButtons = new Map();
  function posFor(idx){
    const angle = (-90 + idx * 30) * Math.PI / 180;
    return { x: center.x + radius * Math.cos(angle), y: center.y + radius * Math.sin(angle) };
  }

  for (let i=0;i<12;i++){
    const pc = FIFTHS[i]; const p = posFor(i);
    const btn = el("div",{
      class:"note",
      style:{ left:(p.x-26)+"px", top:(p.y-26)+"px" },
      title:`${NAMES[pc]} — hover/play (+interval if on), click/sustain, right-click/remove`
    }, NAMES[pc]);

    // HOVER: plays note. If sustained, alternate octave up/down.
    // If Interval is ON, also play interval note (ephemeral) for harmonized melody.
    btn.addEventListener("mouseenter", () => {
      if (!audio.started) return;
      if (!isNoteAllowed(pc)) return;

      // pick hover octave
      let oct = 4;
      const set = sustained.get(pc);
      if (set && set.size){
        const last = lastAlt.get(pc) || "down";
        const dir = last === "down" ? "up" : "down"; lastAlt.set(pc, dir);
        oct = dir === "up" ? Math.min(6, (Math.max(...set) || 4) + 1)
                           : Math.max(2, (Math.min(...set) || 4) - 1);
      }
      hoverPlay(pc, oct);

      // Interval overlay on hover (new)
      if (intervalToggle.classList.contains("on")){
        const iv = INTERVALS[intervalSel.value] || 0;
        const pc2 = PC(pc + iv);
        if (isNoteAllowed(pc2)) hoverPlay(pc2, oct);
      }
    });

    // CLICK: sustain. If Interval ON, sustain root + interval.
    btn.addEventListener("click", e => {
      e.preventDefault();
      if (!audio.started) { resumeAudio(); powerBtn.classList.add("on"); return; }
      if (!isNoteAllowed(pc)) return;

      const addRoot = () => startSustain(pc, (sustained.get(pc)?.size ? pickNextOctave(pc) : 4));
      if (intervalToggle.classList.contains("on")){
        addRoot();
        const iv = INTERVALS[intervalSel.value] || 0;
        const pc2 = PC(pc + iv);
        if (isNoteAllowed(pc2)) startSustain(pc2, 4);
      } else {
        addRoot();
      }
      updateNoteStates(); syncArcs();
    });
    btn.addEventListener("contextmenu", e => { e.preventDefault(); stopSustainNote(pc); updateNoteStates(); });

    circleWrap.appendChild(btn); noteButtons.set(pc, btn);
  }

  // ---------- plasma arcs ----------
  // Animate jittered curves that connect all chosen notes.
  const arcMap = new Map(); // key "a-b" -> {core, halo, seed}
  let animRAF = null;

  function keyPair(a,b){ return a<b ? `${a}-${b}` : `${b}-${a}`; }
  function activePCs(){ return [...sustained.keys()]; }
  function ensureArc(a,b){
    const k = keyPair(a,b);
    if (arcMap.has(k)) return arcMap.get(k);
    const halo = document.createElementNS("http://www.w3.org/2000/svg","path");
    const core = document.createElementNS("http://www.w3.org/2000/svg","path");
    halo.setAttribute("fill","none");
    core.setAttribute("fill","none");
    halo.setAttribute("stroke","#7de3ff");
    core.setAttribute("stroke","#38bdf8");
    halo.setAttribute("stroke-width","8");
    core.setAttribute("stroke-width","2.2");
    halo.setAttribute("opacity","0.35");
    core.setAttribute("opacity","0.95");
    halo.setAttribute("filter","url(#glowWide)");
    core.setAttribute("filter","url(#glow)");
    halo.setAttribute("stroke-linecap","round");
    core.setAttribute("stroke-linecap","round");
    arcLayerBack.appendChild(halo);
    arcLayerFront.appendChild(core);
    const entry = {halo, core, seed: Math.random()*1000};
    arcMap.set(k, entry);
    return entry;
  }
  function clearStaleArcs(){
    const set = new Set();
    const pcs = activePCs();
    for (let i=0;i<pcs.length;i++) for (let j=i+1;j<pcs.length;j++) set.add(keyPair(pcs[i],pcs[j]));
    for (const k of [...arcMap.keys()]){
      if (!set.has(k)){
        const {halo, core} = arcMap.get(k);
        halo.remove(); core.remove(); arcMap.delete(k);
      }
    }
  }
  function syncArcs(){ clearStaleArcs(); /* pairs ensured in draw loop */ }
  function posOfPC(pc){
    const idx = FIFTHS.indexOf(pc); const p = posFor(idx);
    return p;
  }
  // simple smooth noise for plasma wobble
  const fract = v => v - Math.floor(v);
  function noise1(x){ return fract(Math.sin(x*12.9898)*43758.5453); }
  function sCurve(t){ return Math.pow(Math.sin(Math.PI*t), 1.35); } // fade toward ends

  function buildPath(pa,pb,time,seed){
    const dx = pb.x - pa.x, dy = pb.y - pa.y;
    const dist = Math.hypot(dx,dy);
    if (dist < 1) return `M ${pa.x} ${pa.y} L ${pb.x} ${pb.y}`;
    const nx = -dy / dist, ny = dx / dist; // normal
    const segs = dist > 220 ? 16 : 22; // fewer segments for long lines
    const baseAmp = Math.min(18, 8 + dist*0.035); // arc wiggle
    const speed = 0.8;
    let d = `M ${pa.x.toFixed(2)} ${pa.y.toFixed(2)}`;
    for (let i=1;i<=segs;i++){
      const t = i/segs;
      const px = pa.x + dx*t, py = pa.y + dy*t;
      // layered noise: two octaves
      const n1 = noise1((t*3.1 + time*speed) + seed);
      const n2 = noise1((t*7.7 - time*speed*0.6) + seed*0.37);
      const jitter = (n1-0.5)*2*0.65 + (n2-0.5)*2*0.35;
      const amp = baseAmp * sCurve(t);
      const ox = nx * jitter * amp;
      const oy = ny * jitter * amp;
      d += ` L ${(px+ox).toFixed(2)} ${(py+oy).toFixed(2)}`;
    }
    return d;
  }
  function animate(){
    const t = performance.now()/1000;
    const pcs = activePCs();
    if (pcs.length >= 2){
      // ensure all pairs exist
      for (let i=0;i<pcs.length;i++){
        for (let j=i+1;j<pcs.length;j++){
          const a = pcs[i], b = pcs[j];
          const entry = ensureArc(a,b);
          const pa = posOfPC(a), pb = posOfPC(b);
          const pathD = buildPath(pa,pb,t,entry.seed);
          entry.halo.setAttribute("d", pathD);
          entry.core.setAttribute("d", pathD);
          // subtle flicker
          const flick = 0.85 + 0.15*Math.abs(Math.sin((t+entry.seed)*1.7));
          entry.core.setAttribute("opacity", String(0.8 + 0.2*flick));
          entry.halo.setAttribute("opacity", String(0.25 + 0.15*flick));
        }
      }
    }
    animRAF = requestAnimationFrame(animate);
  }
  animRAF = requestAnimationFrame(animate);

  function updateNoteStates(){
    for (const [pc, btn] of noteButtons){
      const on = sustained.has(pc);
      btn.classList.toggle("active", on);
      btn.classList.toggle("inactive", !isNoteAllowed(pc));
    }
  }

  // ---------- controls ----------
  const powerBtn = header.querySelector("#powerBtn");
  powerBtn.addEventListener("click", () => {
    if (!audio.started) { resumeAudio(); powerBtn.classList.add("on"); }
    else { audio.ctx.suspend(); audio.started=false; powerBtn.classList.remove("on"); }
  });

  // drag to move
  (() => {
    let dragging=false,sx=0,sy=0,bx=0,by=0;
    header.addEventListener("mousedown", e => { dragging=true; sx=e.clientX; sy=e.clientY;
      const r = host.getBoundingClientRect(); bx=r.right; by=r.bottom; header.style.cursor="grabbing"; e.preventDefault();
    });
    window.addEventListener("mousemove", e => {
      if (!dragging) return; const dx=e.clientX-sx, dy=e.clientY-sy;
      host.style.right = (document.documentElement.clientWidth - bx - dx) + "px";
      host.style.bottom = (document.documentElement.clientHeight - by - dy) + "px";
    });
    window.addEventListener("mouseup", ()=>{ dragging=false; header.style.cursor="grab"; });
  })();

  const intervalToggle = ctrlTop.querySelector("#intervalToggle");
  const intervalSel = ctrlTop.querySelector("#intervalSel");
  intervalToggle.addEventListener("click", () => intervalToggle.classList.toggle("on"));

  const keyToggle = ctrlTop.querySelector("#keyToggle");
  const keySel = ctrlTop.querySelector("#keySel");
  keyToggle.addEventListener("click", () => { keyToggle.classList.toggle("on"); updateNoteStates(); });
  keySel.addEventListener("change", updateNoteStates);

  function isNoteAllowed(pc){
    if (!keyToggle.classList.contains("on")) return true;
    const v = keySel.value; if (v==="none") return true;
    const [mode, rootIdxStr] = v.split(":"); const rootIdx = parseInt(rootIdxStr,10);
    const scale = mode === "M" ? MAJOR : MINOR;
    return scale.map(s=>PC(rootIdx+s)).includes(pc);
  }

  const randBtn = ctrlTop.querySelector("#randChord");
  randBtn.addEventListener("click", () => {
    const current = [...sustained.keys()];
    const count = current.length; if (!count) return;
    stopAllSustain();

    const pool = []; for (let pc=0; pc<12; pc++) if (isNoteAllowed(pc)) pool.push(pc);
    if (!pool.length) return;

    const chosen = new Set();
    while (chosen.size < Math.min(count, pool.length))
      chosen.add(pool[Math.floor(Math.random()*pool.length)]);

    for (const pc of chosen) startSustain(pc, 4);
    updateNoteStates(); syncArcs();
  });

  // knob hookups
  function hookRange(id, cb){ const r=root.getElementById(id); r.addEventListener("input",()=>cb(parseFloat(r.value))); }
  waveformSel.addEventListener("change", ()=>{ audio.settings.waveform = waveformSel.value; });
  hookRange("kAttack", v=>audio.settings.attack=v);
  hookRange("kDecay", v=>audio.settings.decay=v);
  hookRange("kSustain", v=>audio.settings.sustain=v);
  hookRange("kRelease", v=>audio.settings.release=v);
  hookRange("kCutoff", v=>{ audio.settings.cutoff=v; if(audio.filter) audio.filter.frequency.setValueAtTime(v, now()); });
  hookRange("kRes", v=>{ audio.settings.resonance=v; if(audio.filter) audio.filter.Q.setValueAtTime(v, now()); });
  hookRange("kDetune", v=>{ audio.settings.detune=v; for (const {osc} of voices.values()) osc.detune.setValueAtTime(v, now()); });
  hookRange("kGlide", v=>audio.settings.glide=v);
  hookRange("kVol", v=>{ audio.settings.volume=v; if(audio.master) audio.master.gain.setValueAtTime(v, now()); });
  hookRange("kDelay", v=>{ audio.settings.delayTime=v; if(audio.delay) audio.delay.delayTime.setValueAtTime(v, now()); });
  hookRange("kDelayMix", v=>{ audio.settings.delayMix=v; if(audio.delayGain) audio.delayGain.gain.setValueAtTime(v, now()); });
  hookRange("kFb", v=>{ audio.settings.delayFeedback=v; if(audio.delayFeedback) audio.delayFeedback.gain.setValueAtTime(v, now()); });
  hookRange("kLfoRate", v=>{ audio.settings.lfoRate=v; if(audio.lfo) audio.lfo.frequency.setValueAtTime(v, now()); });
  hookRange("kLfoAmt", v=>{ audio.settings.lfoAmount=v; if(audio.lfoGain) audio.lfoGain.gain.setValueAtTime(v, now()); });
  const lfoTargetSel = root.getElementById("lfoTarget");
  lfoTargetSel.addEventListener("change", ()=>{ audio.lfoTarget=lfoTargetSel.value; for (const v of voices.values()) attachLFOToVoice(v); });

  // start audio on first pointer
  root.addEventListener("pointerdown", () => { if (!audio.started){ resumeAudio(); powerBtn.classList.add("on"); } }, {once:false});

  // initial paint
  function placeNotes(){ for(const [pc,btn] of noteButtons){ const idx=FIFTHS.indexOf(pc); const p=posFor(idx); btn.style.left=(p.x-26)+"px"; btn.style.top=(p.y-26)+"px"; } }
  placeNotes(); updateNoteStates(); syncArcs();
})();
</script>

















</body>
</html>
