<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Fluid Art â€“ Minimal Working</title>
<meta name="viewport" content="width=device-width,initial-scale=1.0">
<script src="https://cdn.jsdelivr.net/npm/@jaames/iro@5.5.3/dist/iro.min.js"></script>
<style>
html,body {
  margin:0; padding:0; height:100%; background:#020c1f; overflow:hidden;
}
#fluid {
  position:fixed; top:0; left:0; width:100%; height:100%;
}
#toolbar {
  position:fixed; bottom:10px; left:50%; transform:translateX(-50%);
  background:rgba(255,255,255,0.1); backdrop-filter:blur(10px);
  border-radius:12px; padding:6px 10px; display:flex; gap:10px; align-items:center;
}
.tool-btn {
  padding:6px 10px; border:none; border-radius:6px; background:rgba(255,255,255,0.2); color:#fff; cursor:pointer;
}
#colorPickerPopup {
  position:fixed; bottom:60px; left:50%; transform:translateX(-50%);
  background:rgba(255,255,255,0.15); border:1px solid rgba(255,255,255,0.3);
  border-radius:12px; padding:8px; display:none;
}
</style>
</head>
<body>

<canvas id="fluid"></canvas>

<div id="toolbar">
  <button class="tool-btn" id="colorBtn">ðŸŽ¨ Color</button>
  <input type="range" id="resolution" min="64" max="256" value="128">
  <button class="tool-btn" id="exportBtn">ðŸ’¾ Export</button>
</div>

<div id="colorPickerPopup"></div>

<script>
(() => {
  const canvas = document.getElementById('fluid');
  const ctx = canvas.getContext('2d', { willReadFrequently:true });
  let DPR=1, W=0, H=0, N=128, size=0;
  let IX, u,v,u0,v0,dR,dG,dB,dR0,dG0,dB0;
  const clamp = (v,a,b)=>v<a?a:v>b?b:v;
  const IXFor = N => (x,y)=>x + y*(N+2);
  function alloc(){
    IX=IXFor(N); size=(N+2)*(N+2);
    u=new Float32Array(size);v=new Float32Array(size);
    u0=new Float32Array(size);v0=new Float32Array(size);
    dR=new Float32Array(size);dG=new Float32Array(size);dB=new Float32Array(size);
    dR0=new Float32Array(size);dG0=new Float32Array(size);dB0=new Float32Array(size);
  }
  function ensureCanvas(){
    DPR=Math.max(1,Math.min(2,window.devicePixelRatio||1));
    W=Math.floor(window.innerWidth*DPR);
    H=Math.floor(window.innerHeight*DPR);
    canvas.width=W; canvas.height=H;
    N=parseInt(document.getElementById('resolution').value)||128;
    alloc();
  }
  function set_bnd(b,x){
    for(let i=1;i<=N;i++){
      x[IX(0,i)]=b===1?-x[IX(1,i)]:x[IX(1,i)];
      x[IX(N+1,i)]=b===1?-x[IX(N,i)]:x[IX(N,i)];
      x[IX(i,0)]=b===2?-x[IX(i,1)]:x[IX(i,1)];
      x[IX(i,N+1)]=b===2?-x[IX(i,N)]:x[IX(i,N)];
    }
    x[IX(0,0)]=0.5*(x[IX(1,0)]+x[IX(0,1)]);
    x[IX(0,N+1)]=0.5*(x[IX(1,N+1)]+x[IX(0,N)]);
    x[IX(N+1,0)]=0.5*(x[IX(N,0)]+x[IX(N+1,1)]);
    x[IX(N+1,N+1)]=0.5*(x[IX(N,N+1)]+x[IX(N+1,N)]);
  }
  function lin_solve(b,x,x0,a,c){
    for(let k=0;k<20;k++){
      for(let j=1;j<=N;j++){
        for(let i=1;i<=N;i++){
          x[IX(i,j)]=(x0[IX(i,j)]+a*(x[IX(i-1,j)]+x[IX(i+1,j)]+x[IX(i,j-1)]+x[IX(i,j+1)]))/c;
        }
      }
      set_bnd(b,x);
    }
  }
  function add_source(x,s,dt){for(let i=0;i<size;i++)x[i]+=dt*s[i];}
  function diffuse(b,x,x0,diff,dt){
    const a=dt*diff*N*N; lin_solve(b,x,x0,a,1+4*a);
  }
  function advect(b,d,d0,u,v,dt){
    const dt0=dt*N;
    for(let j=1;j<=N;j++){
      for(let i=1;i<=N;i++){
        let x=i-dt0*u[IX(i,j)], y=j-dt0*v[IX(i,j)];
        if(x<0.5)x=0.5;if(x>N+0.5)x=N+0.5;
        if(y<0.5)y=0.5;if(y>N+0.5)y=N+0.5;
        const i0=Math.floor(x), i1=i0+1, j0=Math.floor(y), j1=j0+1;
        const s1=x-i0, s0=1-s1, t1=y-j0, t0=1-t1;
        d[IX(i,j)]=
          s0*(t0*d0[IX(i0,j0)]+t1*d0[IX(i0,j1)])+
          s1*(t0*d0[IX(i1,j0)]+t1*d0[IX(i1,j1)]);
      }
    }
    set_bnd(b,d);
  }
  function project(u,v,p,div){
    for(let j=1;j<=N;j++){
      for(let i=1;i<=N;i++){
        div[IX(i,j)]=-0.5*(u[IX(i+1,j)]-u[IX(i-1,j)]+v[IX(i,j+1)]-v[IX(i,j-1)])/N;
        p[IX(i,j)]=0;
      }
    }
    set_bnd(0,div); set_bnd(0,p);
    lin_solve(0,p,div,1,4);
    for(let j=1;j<=N;j++){
      for(let i=1;i<=N;i++){
        u[IX(i,j)]-=0.5*N*(p[IX(i+1,j)]-p[IX(i-1,j)]);
        v[IX(i,j)]-=0.5*N*(p[IX(i,j+1)]-p[IX(i,j-1)]);
      }
    }
    set_bnd(1,u); set_bnd(2,v);
  }
  function vel_step(u,v,u0,v0,visc,dt){
    add_source(u,u0,dt); add_source(v,v0,dt);
    [u0,u]=[u,u0]; diffuse(1,u,u0,visc,dt);
    [v0,v]=[v,v0]; diffuse(2,v,v0,visc,dt);
    project(u,v,u0,v0);
    [u0,u]=[u,u0]; [v0,v]=[v,v0];
    advect(1,u,u0,u0,v0,dt); advect(2,v,v0,u0,v0,dt);
    project(u,v,u0,v0);
    u0.fill(0); v0.fill(0);
  }
  function dens_step(r,g,b,r0,g0,b0,diff,dt){
    add_source(r,r0,dt); add_source(g,g0,dt); add_source(b,b0,dt);
    [r0,r]=[r,r0]; diffuse(0,r,r0,diff,dt);
    [g0,g]=[g,g0]; diffuse(0,g,g0,diff,dt);
    [b0,b]=[b,b0]; diffuse(0,b,b0,diff,dt);
    advect(0,r,r0,u,v,dt); advect(0,g,g0,u,v,dt); advect(0,b,b0,u,v,dt);
    r0.fill(0); g0.fill(0); b0.fill(0);
  }
  function draw(){
    const img=ctx.createImageData(W,H); const pixels=img.data;
    const sx=N/W, sy=N/H; let p=0;
    for(let y=0;y<H;y++){
      const gy=clamp((y*sy+1)|0,1,N);
      for(let x=0;x<W;x++){
        const gx=clamp((x*sx+1)|0,1,N);
        const id=IX(gx,gy);
        pixels[p++]=clamp(dR[id],0,255)|0;
        pixels[p++]=clamp(dG[id],0,255)|0;
        pixels[p++]=clamp(dB[id],0,255)|0;
        pixels[p++]=255;
      }
    }
    ctx.putImageData(img,0,0);
  }
  // Tool
  let holding=false, cursorX=0, cursorY=0, pourColor=[0,170,255];
  function gridFromPx(px,py){
    const x=clamp(((px/W)*(N+2)),1,N);
    const y=clamp(((py/H)*(N+2)),1,N);
    return [x,y];
  }
  function addCircleDye(cx,cy,radius,color){
    const r2=radius*radius;
    for(let j=Math.max(1,(cy-radius)|0);j<=Math.min(N,(cy+radius)|0);j++){
      for(let i=Math.max(1,(cx-radius)|0);i<=Math.min(N,(cx+radius)|0);i++){
        const dx=i-cx, dy=j-cy, d2=dx*dx+dy*dy;
        if(d2<=r2){
          const w=1-d2/r2, id=IX(i,j);
          dR0[id]+=color[0]*w; dG0[id]+=color[1]*w; dB0[id]+=color[2]*w;
        }
      }
    }
  }
  // Events
  canvas.addEventListener('mousedown',e=>{
    holding=true; cursorX=e.offsetX*DPR; cursorY=e.offsetY*DPR;
  });
  window.addEventListener('mouseup',()=>holding=false);
  canvas.addEventListener('mousemove',e=>{
    cursorX=e.offsetX*DPR; cursorY=e.offsetY*DPR;
  });
  // Color picker
  const colorPicker = new iro.ColorPicker('#colorPickerPopup',{width:180,color:'#00aaff',layout:[{component:iro.ui.Wheel}]});
  colorPicker.on('color:change',c=>{pourColor=[c.rgb.r,c.rgb.g,c.rgb.b];});
  document.getElementById('colorBtn').onclick=()=>{
    const pop=document.getElementById('colorPickerPopup');
    pop.style.display = pop.style.display==='block' ? 'none' : 'block';
  };
  // Resolution change
  document.getElementById('resolution').oninput=()=>{
    ensureCanvas();
  };
  // Export
  document.getElementById('exportBtn').onclick=()=>{
    const a=document.createElement('a');
    a.href=canvas.toDataURL('image/png');
    a.download='fluid-art.png'; a.click();
  };
  // Loop
  let last=performance.now();
  function step(now){
    const dt=Math.min(0.033,(now-last)/1000); last=now;
    if(holding){
      const [gx,gy]=gridFromPx(cursorX,cursorY);
      addCircleDye(gx,gy,N*0.05,pourColor);
    }
    vel_step(u,v,u0,v0,0.0008,dt);
    dens_step(dR,dG,dB,dR0,dG0,dB0,0.0005,dt);
    draw();
    requestAnimationFrame(step);
  }
  ensureCanvas(); requestAnimationFrame(step);
})();
</script>
</body>
</html>
