<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Fluid Art Game â€” Ben Sandivar</title>
<link rel="icon" type="image/png" href="assets/favicon.png">
<link rel="shortcut icon" href="assets/favicon.png" type="image/png">
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Gabarito:wght@400;700;900&family=Geologica:wght@300;400;500;700&display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/icon?family=Material+Symbols+Outlined" rel="stylesheet">
<link rel="stylesheet" href="styles.css">
<style>
/* Additional styling for fluid art page */
body {
  margin:0;
  padding:0;
  overflow:hidden;
  background:#020c1f; /* dark background reminiscent of reference image */
  color:#fff;
}
#toolbar {
  position:fixed;
  bottom:20px;
  left:50%;
  transform:translateX(-50%);
  display:flex;
  gap:8px;
  align-items:center;
  padding:8px 12px;
  background:rgba(255,255,255,0.15);
  backdrop-filter:blur(10px);
  border-radius:14px;
  border:1px solid rgba(255,255,255,0.3);
  opacity:0.05;
  transition:opacity 0.3s;
}
#toolbar:hover, #toolbar.show {
  opacity:1;
}
.tool-btn {
  background:rgba(255,255,255,0.2);
  backdrop-filter:blur(4px);
  border:none;
  border-radius:8px;
  padding:6px 10px;
  cursor:pointer;
  color:#fff;
  font-family:inherit;
  font-size:14px;
  display:flex;
  align-items:center;
  gap:4px;
}
.tool-btn.active {
  background:rgba(255,255,255,0.4);
}
.tool-group {
  display:flex;
  gap:4px;
}
#colorSelector {
  width:34px;
  height:34px;
  border-radius:50%;
  position:relative;
  overflow:hidden;
  border:2px solid rgba(255,255,255,0.5);
  cursor:pointer;
}
#colorSelector .swatch {
  position:absolute;
  inset:0;
  border-radius:50%;
}
#colorSelector input[type="color"] {
  position:absolute;
  inset:0;
  opacity:0;
  cursor:pointer;
}
#settingsPanel, #newPanel, #exportPanel {
  position:fixed;
  top:50%;
  left:50%;
  transform:translate(-50%,-50%);
  min-width:280px;
  background:rgba(255,255,255,0.15);
  backdrop-filter:blur(10px);
  border-radius:16px;
  border:1px solid rgba(255,255,255,0.3);
  padding:16px;
  color:#fff;
  z-index:100;
  display:none;
}
.panel-header {
  display:flex;
  justify-content:space-between;
  align-items:center;
  cursor:move;
  margin-bottom:8px;
}
.panel-header h3 {
  margin:0;
  font-size:16px;
}
.panel-header button {
  background:transparent;
  border:none;
  color:#fff;
  font-size:20px;
  cursor:pointer;
}
.panel-content label {
  display:block;
  margin:8px 0 4px;
}
.panel-content input[type="range"], .panel-content input[type="number"], .panel-content select {
  width:100%;
}
.panel-content .row {
  display:flex;
  gap:6px;
  margin-bottom:8px;
}
.tip {
  position:fixed;
  top:80px;
  left:50%;
  transform:translateX(-50%);
  background:rgba(0,0,0,0.6);
  color:#fff;
  padding:6px 12px;
  border-radius:8px;
  backdrop-filter:blur(4px);
  opacity:0;
  transition:opacity 0.3s;
  pointer-events:none;
}
</style>
</head>
<body>
<nav class="navbar">
  <div class="nav-container">
    <a href="/ben-sandivar-site/index.html" class="logo">
      <img src="https://raw.githubusercontent.com/BenS-UI/portfolio/cfc0bc646dc8f7cb21379d516f1b1ca0c0f85e06/B-logo-a.svg" alt="Ben Sandivar Logo">
    </a>
    <button class="more-btn" aria-label="Toggle Menu">
      <span class="material-symbols-outlined">menu</span>
    </button>
    <ul class="nav-links">
      <li><a href="/ben-sandivar-site/index.html#hero">Home</a></li>
      <li><a href="/ben-sandivar-site/index.html#projects">Work</a></li>
      <li><a href="/ben-sandivar-site/index.html#music">Music</a></li>
      <li><a href="/ben-sandivar-site/index.html#about">About</a></li>
      <li><a href="/ben-sandivar-site/index.html#contact">Contact</a></li>
      <li><a href="/ben-sandivar-site/blog.html">Blog</a></li>
    </ul>
  </div>
</nav>
<canvas id="fluid"></canvas>
<div id="toolbar">
  <div id="colorSelector">
    <input id="colorInput" type="color" value="#00aaff">
    <div class="swatch" style="background:#00aaff"></div>
  </div>
  <div class="tool-group" id="colorTools">
    <button class="tool-btn" data-tool="bucket">Bucket</button>
    <button class="tool-btn" data-tool="splatter">Splatter</button>
    <button class="tool-btn" data-tool="spray">Spray</button>
    <button class="tool-btn" data-tool="glitter">Glitter</button>
  </div>
  <div class="tool-group" id="blendTools">
    <button class="tool-btn" data-tool="blender">Blender</button>
    <button class="tool-btn" data-tool="smudge">Smudge</button>
    <button class="tool-btn" data-tool="push">Push</button>
    <button class="tool-btn" data-tool="pinch">Pinch</button>
    <button class="tool-btn" data-tool="ripple">Ripple</button>
  </div>
  <button class="tool-btn" id="newBtn">New</button>
  <button class="tool-btn" id="undoBtn">Undo</button>
  <button class="tool-btn" id="redoBtn">Redo</button>
  <button class="tool-btn" id="exportBtn">Export</button>
  <button class="tool-btn" id="cameraBtn"><span class="material-symbols-outlined">photo_camera</span></button>
  <button class="tool-btn" id="tutorialToggle">Tutorial</button>
</div>
<!-- Settings panel -->
<div id="settingsPanel">
  <div class="panel-header"><h3>Settings</h3><button class="close-btn">&times;</button></div>
  <div class="panel-content">
    <label>Speed <input id="speed" type="range" min="0" max="4" step="0.01" value="1.5"></label>
    <label>Strength <input id="strength" type="range" min="0" max="60" step="0.1" value="24"></label>
    <label>Size <input id="size" type="range" min="10" max="300" step="1" value="120"></label>
    <label>Viscosity <input id="visc" type="range" min="0" max="0.01" step="0.0001" value="0.0008"></label>
    <label>Diffusion <input id="diff" type="range" min="0" max="0.002" step="0.0001" value="0.0005"></label>
  </div>
</div>
<!-- New layout panel -->
<div id="newPanel">
  <div class="panel-header"><h3>New Artwork</h3><button class="close-btn">&times;</button></div>
  <div class="panel-content">
    <label>Number of Colors
      <select id="newColors">
        <option value="1">1</option>
        <option value="2">2</option>
        <option value="3">3</option>
        <option value="4">4</option>
        <option value="5">5</option>
        <option value="6">6</option>
        <option value="7">7</option>
      </select>
    </label>
    <label>Layout
      <select id="newLayout">
        <option value="bisection">Bisection</option>
        <option value="squares">Squares</option>
        <option value="sectors">Radial Sectors</option>
        <option value="rings">Rings</option>
        <option value="spiral">Spiral</option>
        <option value="blotches">Blotches</option>
        <option value="stripes-v">Stripes Vertical</option>
        <option value="stripes-h">Stripes Horizontal</option>
        <option value="random">Random</option>
      </select>
    </label>
    <button class="tool-btn" id="newCreate">Create</button>
  </div>
</div>
<!-- Export panel -->
<div id="exportPanel">
  <div class="panel-header"><h3>Export</h3><button class="close-btn">&times;</button></div>
  <div class="panel-content">
    <label>Format
      <select id="exportFormat">
        <option value="png">PNG</option>
        <option value="jpeg">JPEG</option>
        <option value="webp">WEBP</option>
      </select>
    </label>
    <label>Width <input id="exportWidth" type="number" value="1920" min="100" max="4096"></label>
    <label>Height <input id="exportHeight" type="number" value="1080" min="100" max="4096"></label>
    <label>Quality (JPEG/WEBP) <input id="exportQuality" type="range" min="0.1" max="1" step="0.01" value="0.92"></label>
    <button class="tool-btn" id="exportDownload">Download</button>
  </div>
</div>
<div id="tip" class="tip"></div>
<script src="scripts.js"></script>
<script>
// Fluid Art Simulation Script
(() => {
  const canvas = document.getElementById('fluid');
  const ctx = canvas.getContext('2d', { alpha: false });
  let DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
  let W = 0, H = 0, N = 128;
  let u, v, u0, v0, dR, dG, dB, dR0, dG0, dB0;
  const IX = (x,y) => x + y * (N+2);
  let holding = false;
  let holdButton = 0;
  let holdStart = 0;
  let cursorX = 0, cursorY = 0, prevX = 0, prevY = 0;
  let currentTool = 'bucket';
  let pourColor = [0, 170, 255]; // default electric blue
  const undoStack = [];
  const redoStack = [];
  let tipsEnabled = true;
  const tipsSeen = JSON.parse(localStorage.getItem('fluidTips') || '{}');

  function alloc() {
    const size = (N+2)*(N+2);
    u = new Float32Array(size); v = new Float32Array(size);
    u0 = new Float32Array(size); v0 = new Float32Array(size);
    dR = new Float32Array(size); dG = new Float32Array(size); dB = new Float32Array(size);
    dR0 = new Float32Array(size); dG0 = new Float32Array(size); dB0 = new Float32Array(size);
  }
  function clearFluid() {
    u.fill(0); v.fill(0);
    dR.fill(0); dG.fill(0); dB.fill(0);
  }
  function seedBlueStream() {
    // Fill grid with gradient and noise reminiscent of reference image
    for (let j=1; j<=N; j++) {
      for (let i=1; i<=N; i++) {
        const p = j / N;
        // gradient from electric blue to neon aquamarine
        const r = 0 + (0-0) * p;
        const g = 170 + (255-170) * p;
        const b = 255 + (209-255) * p;
        const noise = Math.random() * 40 - 20;
        const id = IX(i,j);
        dR[id] = Math.min(255, Math.max(0, r + noise));
        dG[id] = Math.min(255, Math.max(0, g + noise));
        dB[id] = Math.min(255, Math.max(0, b + noise));
      }
    }
  }
  function seedLayout(layout, colors) {
    clearFluid();
    const m = colors.length;
    const cols = colors.map(c => {
      const hex = c.replace('#','');
      const n = parseInt(hex.length === 3 ? hex.split('').map(s=>s+s).join('') : hex, 16);
      return [(n>>16)&255, (n>>8)&255, n&255];
    });
    if (layout === 'bisection') {
      for (let j=1; j<=N; j++) {
        for (let i=1; i<=N; i++) {
          const id = IX(i,j);
          const idx = i <= N/2 ? 0 : 1 % m;
          dR[id] = cols[idx][0];
          dG[id] = cols[idx][1];
          dB[id] = cols[idx][2];
        }
      }
    } else if (layout === 'squares') {
      const nSide = Math.ceil(Math.sqrt(m));
      const w = N / nSide;
      let k = 0;
      for (let j=0; j<nSide; j++) {
        for (let i=0; i<nSide; i++) {
          const idx = k % m;
          const c = cols[idx];
          for (let y=1+j*w|0; y<=Math.min(N, (j+1)*w|0); y++) {
            for (let x=1+i*w|0; x<=Math.min(N, (i+1)*w|0); x++) {
              const id = IX(x,y);
              dR[id] = c[0]; dG[id] = c[1]; dB[id] = c[2];
            }
          }
          k++;
        }
      }
    } else if (layout === 'sectors') {
      const cx = (N+2)/2, cy = (N+2)/2;
      for (let j=1; j<=N; j++) {
        for (let i=1; i<=N; i++) {
          const angle = (Math.atan2(j-cy, i-cx) + Math.PI*2) % (Math.PI*2);
          const sector = Math.floor(angle / (2*Math.PI/m));
          const c = cols[sector % m];
          const id = IX(i,j);
          dR[id] = c[0]; dG[id] = c[1]; dB[id] = c[2];
        }
      }
    } else if (layout === 'rings') {
      const cx = (N+2)/2, cy = (N+2)/2;
      const maxDist = Math.hypot(cx,cy);
      for (let j=1; j<=N; j++) {
        for (let i=1; i<=N; i++) {
          const dist = Math.hypot(i-cx, j-cy);
          const ring = Math.floor(dist / (maxDist / m));
          const c = cols[ring % m];
          const id = IX(i,j);
          dR[id] = c[0]; dG[id] = c[1]; dB[id] = c[2];
        }
      }
    } else if (layout === 'spiral') {
      const cx = (N+2)/2, cy = (N+2)/2;
      for (let j=1; j<=N; j++) {
        for (let i=1; i<=N; i++) {
          const dx = i-cx, dy = j-cy;
          const angle = (Math.atan2(dy, dx) + Math.PI*2) % (Math.PI*2);
          const dist = Math.hypot(dx, dy);
          const factor = (angle + dist*0.05) % (2*Math.PI);
          const idx = Math.floor(factor / (2*Math.PI/m));
          const c = cols[idx % m];
          const id = IX(i,j);
          dR[id] = c[0]; dG[id] = c[1]; dB[id] = c[2];
        }
      }
    } else if (layout === 'blotches') {
      // random seeds and Voronoi
      const seeds = [];
      for (let i=0; i<m; i++) {
        seeds.push({
          x: 1 + Math.random()*N,
          y: 1 + Math.random()*N,
          c: cols[i]
        });
      }
      for (let j=1; j<=N; j++) {
        for (let i=1; i<=N; i++) {
          let best = 0;
          let bestDist = Infinity;
          for (let k=0; k<seeds.length; k++) {
            const dx = i-seeds[k].x;
            const dy = j-seeds[k].y;
            const d2 = dx*dx + dy*dy;
            if (d2 < bestDist) { bestDist = d2; best = k; }
          }
          const c = seeds[best].c;
          const id = IX(i,j);
          dR[id] = c[0]; dG[id] = c[1]; dB[id] = c[2];
        }
      }
    } else if (layout === 'stripes-v' || layout === 'stripes-h') {
      const stripes = m;
      if (layout === 'stripes-v') {
        const stripeW = N / stripes;
        for (let j=1; j<=N; j++) {
          for (let i=1; i<=N; i++) {
            const idx = Math.floor((i-1)/stripeW) % m;
            const c = cols[idx];
            const id = IX(i,j);
            dR[id] = c[0]; dG[id] = c[1]; dB[id] = c[2];
          }
        }
      } else {
        const stripeH = N / stripes;
        for (let j=1; j<=N; j++) {
          const idx = Math.floor((j-1)/stripeH) % m;
          const c = cols[idx];
          for (let i=1; i<=N; i++) {
            const id = IX(i,j);
            dR[id] = c[0]; dG[id] = c[1]; dB[id] = c[2];
          }
        }
      }
    } else if (layout === 'random') {
      for (let j=1; j<=N; j++) {
        for (let i=1; i<=N; i++) {
          const idx = Math.floor(Math.random()*m);
          const c = cols[idx];
          const id = IX(i,j);
          dR[id] = c[0]; dG[id] = c[1]; dB[id] = c[2];
        }
      }
    }
  }
  function pushUndo() {
    // copy current dye to stack
    const snapshotR = new Float32Array(dR);
    const snapshotG = new Float32Array(dG);
    const snapshotB = new Float32Array(dB);
    undoStack.push({r: snapshotR, g: snapshotG, b: snapshotB});
    if (undoStack.length > 20) undoStack.shift();
    redoStack.length = 0;
  }
  function undo() {
    if (undoStack.length === 0) return;
    const state = undoStack.pop();
    const current = {r: new Float32Array(dR), g: new Float32Array(dG), b: new Float32Array(dB)};
    redoStack.push(current);
    dR.set(state.r); dG.set(state.g); dB.set(state.b);
  }
  function redo() {
    if (redoStack.length === 0) return;
    const state = redoStack.pop();
    undoStack.push({r: new Float32Array(dR), g: new Float32Array(dG), b: new Float32Array(dB)});
    dR.set(state.r); dG.set(state.g); dB.set(state.b);
  }
  function showTip(message) {
    if (!tipsEnabled) return;
    const tipEl = document.getElementById('tip');
    tipEl.textContent = message;
    tipEl.style.opacity = '1';
    clearTimeout(tipEl._timeout);
    tipEl._timeout = setTimeout(() => {
      tipEl.style.opacity = '0';
    }, 4000 + message.length * 20);
  }
  function maybeTip(tool) {
    if (!tipsEnabled) return;
    if (tipsSeen[tool]) return;
    const messages = {
      bucket: "Bucket: hold to pour clean color.",
      splatter: "Splatter: hold to drop random paint with spin.",
      spray: "Spray: hold to spray fine mist of color.",
      glitter: "Glitter: hold to sprinkle shimmering paint.",
      blender: "Blender: hold to spin paint; right-click reverses spin.",
      smudge: "Smudge: hold and drag to smear paint.",
      push: "Push: hold and drag to push paint outward.",
      pinch: "Pinch: hold and drag to pinch paint inward.",
      ripple: "Ripple: hold to create rippling waves."
    };
    if (messages[tool]) {
      showTip(messages[tool]);
      tipsSeen[tool] = true;
      localStorage.setItem('fluidTips', JSON.stringify(tipsSeen));
    }
  }
  // Fluid solver functions
  let iter = 20;
  function set_bnd(b, x) {
    for(let i=1;i<=N;i++){
      x[IX(0,i)]   = b===1 ? -x[IX(1,i)]   : x[IX(1,i)];
      x[IX(N+1,i)] = b===1 ? -x[IX(N,i)]   : x[IX(N,i)];
      x[IX(i,0)]   = b===2 ? -x[IX(i,1)]   : x[IX(i,1)];
      x[IX(i,N+1)] = b===2 ? -x[IX(i,N)]   : x[IX(i,N)];
    }
    x[IX(0,0)]         = 0.5*(x[IX(1,0)]     + x[IX(0,1)]);
    x[IX(0,N+1)]       = 0.5*(x[IX(1,N+1)]   + x[IX(0,N)]);
    x[IX(N+1,0)]       = 0.5*(x[IX(N,0)]     + x[IX(N+1,1)]);
    x[IX(N+1,N+1)]     = 0.5*(x[IX(N,N+1)]   + x[IX(N+1,N)]);
  }
  function lin_solve(b, x, x0, a, c) {
    const cRecip = 1.0 / c;
    for (let k=0; k<iter; k++) {
      for (let j=1; j<=N; j++) {
        for (let i=1; i<=N; i++) {
          x[IX(i,j)] = (x0[IX(i,j)] + a*(x[IX(i-1,j)] + x[IX(i+1,j)] + x[IX(i,j-1)] + x[IX(i,j+1)])) * cRecip;
        }
      }
      set_bnd(b,x);
    }
  }
  function diffuse(b,x,x0,diff,dt) {
    const a = dt * diff * N * N;
    lin_solve(b,x,x0,a,1+4*a);
  }
  function advect(b,d,d0,u,v,dt) {
    const dt0 = dt * N;
    for(let j=1;j<=N;j++){
      for(let i=1;i<=N;i++){
        let x = i - dt0 * u[IX(i,j)];
        let y = j - dt0 * v[IX(i,j)];
        if (x<0.5) x=0.5;
        if (x>N+0.5) x=N+0.5;
        const i0 = x|0, i1 = i0+1;
        if (y<0.5) y=0.5;
        if (y>N+0.5) y=N+0.5;
        const j0 = y|0, j1 = j0+1;
        const s1 = x - i0, s0 = 1 - s1;
        const t1 = y - j0, t0 = 1 - t1;
        d[IX(i,j)] =
          s0 * (t0 * d0[IX(i0,j0)] + t1 * d0[IX(i0,j1)]) +
          s1 * (t0 * d0[IX(i1,j0)] + t1 * d0[IX(i1,j1)]);
      }
    }
    set_bnd(b,d);
  }
  function project(u,v,p,div) {
    for(let j=1;j<=N;j++){
      for(let i=1;i<=N;i++){
        div[IX(i,j)] = -0.5*(u[IX(i+1,j)] - u[IX(i-1,j)] + v[IX(i,j+1)] - v[IX(i,j-1)]) / N;
        p[IX(i,j)] = 0;
      }
    }
    set_bnd(0,div); set_bnd(0,p);
    lin_solve(0,p,div,1,4);
    for(let j=1;j<=N;j++){
      for(let i=1;i<=N;i++){
        u[IX(i,j)] -= 0.5*N*(p[IX(i+1,j)] - p[IX(i-1,j)]);
        v[IX(i,j)] -= 0.5*N*(p[IX(i,j+1)] - p[IX(i,j-1)]);
      }
    }
    set_bnd(1,u); set_bnd(2,v);
  }
  function vel_step(u,v,u0,v0,visc,dt) {
    // Add velocities
    for(let i=0;i<u.length;i++) { u[i] += u0[i]; v[i] += v0[i]; u0[i] = 0; v0[i] = 0; }
    diffuse(1,u0,u,visc,dt); diffuse(2,v0,v,visc,dt);
    project(u0,v0,u,v);
    advect(1,u,u0,u0,v0,dt); advect(2,v,v0,u0,v0,dt);
    project(u,v,u0,v0);
  }
  function dens_step(r,g,b,r0,g0,b0,diff,dt) {
    diffuse(0,r0,r,diff,dt); diffuse(0,g0,g,diff,dt); diffuse(0,b0,b,diff,dt);
    advect(0,r,r0,u,v,dt); advect(0,g,g0,u,v,dt); advect(0,b,b0,u,v,dt);
  }
  // Tool implementations
  function addBucketPaint(dt) {
    const radius = +sizeEl.value * DPR;
    const rate = Math.min(2, 40*dt);
    const [cx,cy] = gridFromPx(cursorX, cursorY);
    const rG = radius * (N / Math.max(W, H));
    const r2 = rG*rG;
    const [rC,gC,bC] = pourColor;
    for(let j=1;j<=N;j++){
      for(let i=1;i<=N;i++){
        const dx = i - cx;
        const dy = j - cy;
        const dist2 = dx*dx + dy*dy;
        if(dist2 > r2) continue;
        const w = 1 - dist2/r2;
        const id = IX(i,j);
        dR[id] += (rC - dR[id]) * w * rate;
        dG[id] += (gC - dG[id]) * w * rate;
        dB[id] += (bC - dB[id]) * w * rate;
      }
    }
  }
  let splatterCarry = 0;
  function addSplatter(dt) {
    const radius = +sizeEl.value * DPR;
    const spinStrength = +strengthEl.value;
    const speed = +speedEl.value;
    let rate = 40 * speed * dt + splatterCarry;
    let drops = Math.floor(rate);
    splatterCarry = rate - drops;
    const [cx,cy] = gridFromPx(cursorX, cursorY);
    for(let n=0;n<drops;n++){
      const ang = Math.random() * Math.PI * 2;
      const dist = Math.random() * radius;
      const gx = clamp((cx + (dist * Math.cos(ang))*(N/Math.max(W,H)))|0,1,N);
      const gy = clamp((cy + (dist * Math.sin(ang))*(N/Math.max(W,H)))|0,1,N);
      const dropR = (0.1 + Math.random()*0.9) * radius*(N/Math.max(W,H));
      const r2 = dropR * dropR;
      for(let j=(gy-dropR)|0;j<=(gy+dropR)|0;j++){
        if(j<1||j>N) continue;
        for(let i=(gx-dropR)|0;i<=(gx+dropR)|0;i++){
          if(i<1||i>N) continue;
          const dx = i-gx;
          const dy = j-gy;
          const d2 = dx*dx + dy*dy;
          if(d2>r2) continue;
          const w = 1 - d2/r2;
          const id = IX(i,j);
          dR[id] += (pourColor[0] - dR[id]) * w;
          dG[id] += (pourColor[1] - dG[id]) * w;
          dB[id] += (pourColor[2] - dB[id]) * w;
          if (spinStrength > 0.1) {
            const dist1 = Math.sqrt(d2) + 1e-6;
            const tx = -dy / dist1;
            const ty = dx / dist1;
            const f = dt * spinStrength * 0.3 * (1 - d2/r2) * (holdButton === 2 ? -1 : 1);
            u0[IX(i,j)] += tx * f;
            v0[IX(i,j)] += ty * f;
          }
        }
      }
    }
  }
  let sprayCarry = 0;
  function addSpray(dt) {
    const radius = +sizeEl.value * DPR;
    const [cx, cy] = [cursorX, cursorY];
    let rate = 200 * dt + sprayCarry;
    const count = Math.floor(rate);
    sprayCarry = rate - count;
    for(let i=0; i<count; i++){
      const ang = Math.random() * 2 * Math.PI;
      const dist = Math.random() * radius;
      const px = cx + dist * Math.cos(ang);
      const py = cy + dist * Math.sin(ang);
      const [gx,gy] = gridFromPx(px, py);
      const id = IX(gx|0, gy|0);
      const noise = Math.random()*0.3+0.7;
      dR[id] = dR[id] + (pourColor[0]*noise - dR[id]) * 0.5;
      dG[id] = dG[id] + (pourColor[1]*noise - dG[id]) * 0.5;
      dB[id] = dB[id] + (pourColor[2]*noise - dB[id]) * 0.5;
    }
  }
  let glitterCarry = 0;
  function addGlitter(dt) {
    const radius = +sizeEl.value * DPR;
    let rate = 150 * dt + glitterCarry;
    const count = Math.floor(rate);
    glitterCarry = rate - count;
    for(let i=0; i<count; i++){
      const ang = Math.random() * 2 * Math.PI;
      const dist = Math.random() * radius;
      const px = cursorX + dist * Math.cos(ang);
      const py = cursorY + dist * Math.sin(ang);
      const [gx,gy] = gridFromPx(px, py);
      const id = IX(gx|0, gy|0);
      const brightness = (Math.random()*0.8 + 0.3);
      dR[id] = dR[id] + (pourColor[0]*brightness - dR[id]) * 0.7;
      dG[id] = dG[id] + (pourColor[1]*brightness - dG[id]) * 0.7;
      dB[id] = dB[id] + (pourColor[2]*brightness - dB[id]) * 0.7;
    }
  }
  function addBlender(dt) {
    const radius = +sizeEl.value * DPR;
    const [cx,cy] = gridFromPx(cursorX, cursorY);
    const rG = radius * (N / Math.max(W,H));
    const r2 = rG*rG;
    const str = +strengthEl.value;
    const dir = holdButton === 2 ? -1 : 1;
    for(let j=1;j<=N;j++){
      for(let i=1;i<=N;i++){
        const dx = i - cx;
        const dy = j - cy;
        const dist2 = dx*dx + dy*dy;
        if(dist2>r2) continue;
        const dist = Math.sqrt(dist2) + 1e-6;
        const tx = -dy / dist;
        const ty = dx / dist;
        const w = 1 - dist2/r2;
        const f = dt * +speedEl.value * str * w * dir;
        u0[IX(i,j)] += tx * f;
        v0[IX(i,j)] += ty * f;
      }
    }
  }
  function addSmudge(dt) {
    if (isNaN(prevX)) return;
    const radius = +sizeEl.value * DPR;
    const [cx,cy] = gridFromPx(cursorX, cursorY);
    const [pcx,pcy] = gridFromPx(prevX, prevY);
    const mvx = cx - pcx, mvy = cy - pcy;
    const len = Math.hypot(mvx, mvy) + 1e-6;
    const sx = mvx / len, sy = mvy / len;
    const rG = radius * (N/Math.max(W,H));
    const r2 = rG * rG;
    const pull = +strengthEl.value * 0.6 * (1 + +speedEl.value*0.2);
    for(let j=1;j<=N;j++){
      for(let i=1;i<=N;i++){
        const dx = i - cx;
        const dy = j - cy;
        const dist2 = dx*dx + dy*dy;
        if(dist2>r2) continue;
        const w = 1 - dist2/r2;
        const id = IX(i,j);
        const srcX = clamp((i - sx * 3)|0,1,N);
        const srcY = clamp((j - sy * 3)|0,1,N);
        const sid = IX(srcX, srcY);
        const a = w * pull * dt;
        dR[id] += (dR[sid] - dR[id]) * a;
        dG[id] += (dG[sid] - dG[id]) * a;
        dB[id] += (dB[sid] - dB[id]) * a;
      }
    }
  }
  function addPush(dt) {
    if (isNaN(prevX)) return;
    const radius = +sizeEl.value * DPR;
    const [cx,cy] = gridFromPx(cursorX, cursorY);
    const [pcx,pcy] = gridFromPx(prevX, prevY);
    const mvx = cx - pcx, mvy = cy - pcy;
    const len = Math.hypot(mvx, mvy) + 1e-6;
    const vx = mvx / len, vy = mvy / len;
    const rG = radius * (N/Math.max(W,H));
    const r2v = rG*rG;
    const force = +strengthEl.value * 0.5;
    for(let j=1;j<=N;j++){
      for(let i=1;i<=N;i++){
        const dx = i - cx;
        const dy = j - cy;
        const dist2 = dx*dx + dy*dy;
        if(dist2>r2v) continue;
        const w = 1 - dist2/r2v;
        const id = IX(i,j);
        u0[id] += vx * w * force * dt;
        v0[id] += vy * w * force * dt;
      }
    }
  }
  function addPinch(dt) {
    if (isNaN(prevX)) return;
    const radius = +sizeEl.value * DPR;
    const [cx,cy] = gridFromPx(cursorX, cursorY);
    const [pcx,pcy] = gridFromPx(prevX, prevY);
    const mvx = cx - pcx, mvy = cy - pcy;
    const len = Math.hypot(mvx, mvy) + 1e-6;
    const vx = mvx / len, vy = mvy / len;
    const rG = radius * (N/Math.max(W,H));
    const r2v = rG*rG;
    const force = +strengthEl.value * 0.5;
    for(let j=1;j<=N;j++){
      for(let i=1;i<=N;i++){
        const dx = i - cx;
        const dy = j - cy;
        const dist2 = dx*dx + dy*dy;
        if(dist2>r2v) continue;
        const w = 1 - dist2/r2v;
        const id = IX(i,j);
        u0[id] -= vx * w * force * dt;
        v0[id] -= vy * w * force * dt;
      }
    }
  }
  let ripplePhase = 0;
  function addRipple(dt) {
    const radius = +sizeEl.value * DPR;
    const [cx,cy] = gridFromPx(cursorX, cursorY);
    const rG = radius * (N/Math.max(W,H));
    const r2v = rG*rG;
    ripplePhase += dt * 4;
    const amp0 = +strengthEl.value * 0.1;
    for(let j=1;j<=N;j++){
      for(let i=1;i<=N;i++){
        const dx = i - cx;
        const dy = j - cy;
        const dist2 = dx*dx + dy*dy;
        if(dist2>r2v) continue;
        const dist = Math.sqrt(dist2)+1e-6;
        const w = 1 - dist2/r2v;
        const amp = Math.sin((dist / rG) * Math.PI * 4 - ripplePhase) * amp0 * w;
        const id = IX(i,j);
        u0[id] += (dx/dist) * amp * dt;
        v0[id] += (dy/dist) * amp * dt;
      }
    }
  }
  function clamp(v,a,b){ return v < a ? a : (v > b ? b : v); }
  function gridFromPx(px, py) {
    const x = clamp(((px / W) * (N+2)), 1, N);
    const y = clamp(((py / H) * (N+2)), 1, N);
    return [x,y];
  }
  function ensureCanvas() {
    DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    W = Math.floor(window.innerWidth * DPR);
    H = Math.floor(window.innerHeight * DPR);
    canvas.width = W;
    canvas.height = H;
    canvas.style.width = '100vw';
    canvas.style.height = '100vh';
    // choose grid size based on screen
    const area = window.innerWidth * window.innerHeight;
    const target = Math.sqrt(area / 180000);
    N = clamp(Math.floor(120 * target), 96, 256);
    alloc();
    seedBlueStream();
  }
  window.addEventListener('resize', ensureCanvas);
  // UI elements
  const speedEl = document.getElementById('speed');
  const strengthEl = document.getElementById('strength');
  const sizeEl = document.getElementById('size');
  const viscEl = document.getElementById('visc');
  const diffEl = document.getElementById('diff');
  const colorInput = document.getElementById('colorInput');
  const colorSwatch = document.querySelector('#colorSelector .swatch');
  const toolbar = document.getElementById('toolbar');
  // Buttons
  document.querySelectorAll('#colorTools .tool-btn, #blendTools .tool-btn').forEach(btn => {
    btn.addEventListener('click', () => {
      document.querySelectorAll('#colorTools .tool-btn, #blendTools .tool-btn').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      currentTool = btn.dataset.tool;
      maybeTip(currentTool);
    });
  });
  document.getElementById('undoBtn').addEventListener('click', () => { undo(); });
  document.getElementById('redoBtn').addEventListener('click', () => { redo(); });
  document.getElementById('tutorialToggle').addEventListener('click', () => {
    tipsEnabled = !tipsEnabled;
    document.getElementById('tutorialToggle').textContent = tipsEnabled ? 'Tutorial' : 'Tutorial Off';
  });
  // New
  document.getElementById('newBtn').addEventListener('click', () => {
    openPanel(newPanel);
  });
  document.getElementById('newCreate').addEventListener('click', () => {
    const count = parseInt(document.getElementById('newColors').value);
    const layout = document.getElementById('newLayout').value;
    // generate random colors
    const cols = [];
    for(let i=0; i<count; i++){
      const r = Math.floor(50+Math.random()*205);
      const g = Math.floor(50+Math.random()*205);
      const b = Math.floor(50+Math.random()*205);
      cols.push('#'+((1<<24)+(r<<16)+(g<<8)+b).toString(16).slice(1));
    }
    seedLayout(layout, cols);
    pushUndo();
    closePanel(newPanel);
  });
  // Export
  document.getElementById('exportBtn').addEventListener('click', () => {
    openPanel(exportPanel);
  });
  document.getElementById('exportDownload').addEventListener('click', () => {
    const format = document.getElementById('exportFormat').value;
    let width = parseInt(document.getElementById('exportWidth').value) || W;
    let height = parseInt(document.getElementById('exportHeight').value) || H;
    width = clamp(width, 100, 4096);
    height = clamp(height, 100, 4096);
    const quality = parseFloat(document.getElementById('exportQuality').value) || 0.92;
    exportImage(format, width, height, quality);
  });
  document.getElementById('cameraBtn').addEventListener('click', () => {
    exportImage('jpeg', W, H, 0.92);
  });
  // Panels
  const settingsPanel = document.getElementById('settingsPanel');
  const newPanel = document.getElementById('newPanel');
  const exportPanel = document.getElementById('exportPanel');
  document.querySelectorAll('.close-btn').forEach(btn => {
    btn.addEventListener('click', (e) => {
      closePanel(e.target.closest('div'));
    });
  });
  function openPanel(panel) {
    panel.style.display = 'block';
    setTimeout(() => { panel.classList.add('open'); }, 10);
    document.addEventListener('mousedown', outsideClick);
  }
  function closePanel(panel) {
    panel.classList.remove('open');
    panel.style.display = 'none';
    document.removeEventListener('mousedown', outsideClick);
  }
  function outsideClick(e) {
    if (!settingsPanel.contains(e.target) && !newPanel.contains(e.target) && !exportPanel.contains(e.target) && !toolbar.contains(e.target)) {
      [settingsPanel, newPanel, exportPanel].forEach(p => { p.style.display='none'; p.classList.remove('open'); });
      document.removeEventListener('mousedown', outsideClick);
    }
  }
  // Drag for panels
  document.querySelectorAll('#settingsPanel .panel-header, #newPanel .panel-header, #exportPanel .panel-header').forEach(header => {
    let offsetX=0, offsetY=0, dragging=false;
    header.addEventListener('mousedown', e => {
      dragging = true;
      const rect = header.parentElement.getBoundingClientRect();
      offsetX = e.clientX - rect.left;
      offsetY = e.clientY - rect.top;
      document.addEventListener('mousemove', drag);
      document.addEventListener('mouseup', stop);
    });
    function drag(e) {
      if (!dragging) return;
      const panel = header.parentElement;
      panel.style.left = (e.clientX - offsetX) + 'px';
      panel.style.top = (e.clientY - offsetY) + 'px';
      panel.style.transform = '';
    }
    function stop() {
      dragging = false;
      document.removeEventListener('mousemove', drag);
      document.removeEventListener('mouseup', stop);
    }
  });
  // Color input
  colorInput.addEventListener('input', () => {
    const hex = colorInput.value.toLowerCase();
    colorSwatch.style.background = hex;
    const n = parseInt(hex.replace('#',''), 16);
    pourColor = [(n>>16)&255, (n>>8)&255, n&255];
  });
  document.getElementById('colorSelector').addEventListener('click', () => {
    colorInput.showPicker && colorInput.showPicker();
  });
  // Settings from right-click
  canvas.addEventListener('contextmenu', (e) => {
    e.preventDefault();
    // open settings only if not holding
    if(!holding) {
      openPanel(settingsPanel);
    }
  });
  // Input events
  canvas.addEventListener('mousedown', (e) => {
    if (e.button === 0 || e.button === 2) {
      holding = true;
      holdButton = e.button;
      holdStart = performance.now();
      cursorX = e.offsetX * DPR;
      cursorY = e.offsetY * DPR;
      prevX = cursorX; prevY = cursorY;
      maybeTip(currentTool);
      e.preventDefault();
    }
  });
  window.addEventListener('mouseup', (e) => {
    if (holding && (e.button === holdButton)) {
      const duration = performance.now() - holdStart;
      holding = false;
      if (holdButton === 2 && duration < 200) {
        // quick right click -> open settings
        openPanel(settingsPanel);
      } else {
        pushUndo();
      }
    }
  });
  canvas.addEventListener('mousemove', (e) => {
    const x = e.offsetX * DPR;
    const y = e.offsetY * DPR;
    if (holding) {
      prevX = cursorX;
      prevY = cursorY;
    }
    cursorX = x; cursorY = y;
  });
  canvas.addEventListener('touchstart', (e) => {
    const t = e.touches[0];
    const rect = canvas.getBoundingClientRect();
    holding = true;
    holdButton = 0;
    cursorX = (t.clientX - rect.left) * DPR;
    cursorY = (t.clientY - rect.top) * DPR;
    prevX = cursorX; prevY = cursorY;
    maybeTip(currentTool);
    e.preventDefault();
  }, {passive:false});
  canvas.addEventListener('touchmove', (e) => {
    const t = e.touches[0];
    const rect = canvas.getBoundingClientRect();
    prevX = cursorX;
    prevY = cursorY;
    cursorX = (t.clientX - rect.left) * DPR;
    cursorY = (t.clientY - rect.top) * DPR;
    e.preventDefault();
  }, {passive:false});
  canvas.addEventListener('touchend', () => {
    holding = false;
    pushUndo();
  }, {passive:true});
  // Keyboard shortcuts
  window.addEventListener('keydown', (e) => {
    if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'z') {
      e.preventDefault();
      if (e.shiftKey) { redo(); } else { undo(); }
    }
    if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'y') {
      e.preventDefault();
      redo();
    }
    if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'p') {
      e.preventDefault();
      exportImage('jpeg', W, H, 0.92);
    }
    if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 's') {
      e.preventDefault();
      openPanel(exportPanel);
    }
  });
  function exportImage(format, width, height, quality) {
    // copy canvas to offscreen at new resolution
    const off = document.createElement('canvas');
    off.width = width;
    off.height = height;
    const offCtx = off.getContext('2d');
    // draw scaled image
    offCtx.drawImage(canvas, 0, 0, width, height);
    const mime = format === 'png' ? 'image/png' :
                 format === 'jpeg' ? 'image/jpeg' : 'image/webp';
    off.toBlob((blob) => {
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      const date = new Date().toISOString().replace(/[:.]/g,'-');
      a.download = 'fluid-art-' + date + '.' + format;
      document.body.appendChild(a);
      a.click();
      a.remove();
      setTimeout(() => URL.revokeObjectURL(url), 1000);
    }, mime, quality);
    closePanel(exportPanel);
  }
  // Render
  let img, pixels;
  function ensureImage() {
    if (!img || img.width !== W || img.height !== H) {
      img = ctx.createImageData(W, H);
      pixels = img.data;
    }
  }
  function draw() {
    ensureImage();
    const sx = N / W;
    const sy = N / H;
    let p = 0;
    for(let y=0; y<H; y++){
      const gy = clamp((y*sy+1)|0, 1, N);
      for(let x=0; x<W; x++){
        const gx = clamp((x*sx+1)|0, 1, N);
        const id = IX(gx, gy);
        pixels[p++] = clamp(dR[id], 0, 255)|0;
        pixels[p++] = clamp(dG[id], 0, 255)|0;
        pixels[p++] = clamp(dB[id], 0, 255)|0;
        pixels[p++] = 255;
      }
    }
    ctx.putImageData(img, 0, 0);
  }
  // Main loop
  let lastT = performance.now();
  function step(now) {
    const dt = Math.min(0.033, (now - lastT) / 1000) * +speedEl.value;
    lastT = now;
    // Tools
    if (holding) {
      if (currentTool === 'bucket') addBucketPaint(dt);
      else if (currentTool === 'splatter') addSplatter(dt);
      else if (currentTool === 'spray') addSpray(dt);
      else if (currentTool === 'glitter') addGlitter(dt);
      else if (currentTool === 'blender') addBlender(dt);
      else if (currentTool === 'smudge') addSmudge(dt);
      else if (currentTool === 'push') addPush(dt);
      else if (currentTool === 'pinch') addPinch(dt);
      else if (currentTool === 'ripple') addRipple(dt);
    }
    // Fluid simulation
    vel_step(u, v, u0, v0, +viscEl.value, dt);
    // fade dyes slightly
    for(let i=0;i<dR0.length;i++){
      dR0[i] = dR[i] * 0.999;
      dG0[i] = dG[i] * 0.999;
      dB0[i] = dB[i] * 0.999;
    }
    dens_step(dR, dG, dB, dR0, dG0, dB0, +diffEl.value, dt);
    draw();
    requestAnimationFrame(step);
  }
  ensureCanvas();
  requestAnimationFrame(step);
})();
</script>
</body>
</html>
