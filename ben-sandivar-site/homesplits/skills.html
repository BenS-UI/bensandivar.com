<!-- homesplits/skills.html -->
<section id="skills" class="about-skills fade-in" data-split="skills">
  <div class="page-header">
    <h2>Skills and Tools</h2>
    <p>A multidisciplinary toolkit honed over years of practice, blending creativity with technical precision.</p>
  </div>

  <div class="skills-grid">
    <span>Speed Learning</span>
    <span>Teaching</span>
    <span>Mnemonics</span>
    <span>Graphic Design</span>
    <span>Concept Art</span>
    <span>Character Creation</span>
    <span>Photo & Video Editing</span>
    <span>Logo Creation</span>
    <span>Branding</span>
    <span>App Concept Creation</span>
    <span>AI Prompt Engineering</span>
    <span>Creative Writing</span>
    <span>Songwriting & Poetry</span>
    <span>Audio Engineering</span>
    <span>Music Production</span>
    <span>Cinematic Composition</span>
    <span>Concept Design</span>
    <span>Systems Thinking</span>
    <span>Linguistics & Sociology</span>
    <span>Semiotics & Symbols</span>
    <span>Public Speaking & Communication</span>
    <span>Project Management</span>
    <span>Cinematography</span>
  </div>
</section>

<script>
(() => {
  // ===== NOTE GENERATION =====
  const NOTES = ["G","A","B","C","D","E","F#"];
  const OCTAVES = [3,4,5];

  const NOTE_INDEX = { C:0,"C#":1,D:2,"D#":3,E:4,F:5,"F#":6,G:7,"G#":8,A:9,"A#":10,B:11 };
  const toFreq = (note, octave) => {
    const midi = 12 * (octave + 1) + NOTE_INDEX[note];
    return 440 * Math.pow(2, (midi - 69) / 12);
  };

  // Build and shuffle pool
  const pool = [];
  OCTAVES.forEach(o => NOTES.forEach(n => pool.push({ n, o, f: toFreq(n, o) })));
  for (let i = pool.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [pool[i], pool[j]] = [pool[j], pool[i]];
  }

  const chips = document.querySelectorAll(".skills-grid span");
  if (!chips.length) return;

  // Assign notes to chips
  chips.forEach((el, i) => {
    const pick = pool[i % pool.length];
    el.dataset.note = pick.n;
    el.dataset.octave = pick.o;
    el.dataset.freq = pick.f.toFixed(3);
    el.title = `${pick.n}${pick.o}`;
    el.setAttribute("aria-label", `${pick.n}${pick.o}`);
  });

  // ===== AUDIO SETUP =====
  let ctx = null;
  const getCtx = () => ctx || (ctx = new (window.AudioContext || window.webkitAudioContext)());

  const play = (freq) => {
    const audio = getCtx();
    const now = audio.currentTime;

    const gain = audio.createGain();
    gain.gain.setValueAtTime(0.0001, now);
    gain.gain.exponentialRampToValueAtTime(0.6, now + 0.01);
    gain.gain.exponentialRampToValueAtTime(0.55, now + 0.08);
    gain.gain.exponentialRampToValueAtTime(0.001, now + 2.5);

    const filter = audio.createBiquadFilter();
    filter.type = "lowpass";
    filter.frequency.setValueAtTime(6200, now);
    filter.Q.value = 0.7;

    const o1 = audio.createOscillator();
    o1.type = "sine";
    o1.frequency.setValueAtTime(freq, now);

    const o2 = audio.createOscillator();
    o2.type = "sine";
    o2.frequency.setValueAtTime(freq * Math.pow(2, 2/1200), now); // +2 cents

    o1.connect(filter);
    o2.connect(filter);
    filter.connect(gain).connect(audio.destination);

    o1.start(now);
    o2.start(now);
    o1.stop(now + 2.6);
    o2.stop(now + 2.6);
  };

  // ===== HOVER EVENTS =====
  const lastPlayed = new WeakMap(); // debounce per button
  const HOVER_DELAY = 500; // ms between replays for same button

  chips.forEach(el => {
    el.addEventListener("mouseenter", () => {
      // Resume context on first hover if needed
      getCtx().resume().then(() => {
        const now = Date.now();
        const last = lastPlayed.get(el) || 0;
        if (now - last >= HOVER_DELAY) {
          play(parseFloat(el.dataset.freq));
          lastPlayed.set(el, now);
        }
      });
    });
  });
})();
</script>
