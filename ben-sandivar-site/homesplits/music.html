<section id="music" class="music-player fade-in" data-split="music">
  <div class="page-header">
    <h2>Music</h2>
    <p>Albums and tracks in a simple player.</p>
  </div>

  <div class="music-shell">
    <!-- view switch -->
    <div class="mode-lights" role="group" aria-label="View switch">
      <button id="light-list" class="light on" aria-label="List view"></button>
      <button id="light-track" class="light" aria-label="Track view"></button>
      <div class="hint" role="note">Tap a dot to switch views</div>
    </div>

    <!-- content -->
    <div class="views-wrap" id="viewsWrap">
      <div id="albums-view" class="albums-view" aria-live="polite"></div>

      <!-- Track view: art only -->
      <div id="track-view" class="track-view hidden">
        <div class="track-stage">
          <div class="stage-art-wrap">
            <img id="stage-art" src="" alt="Album art">
          </div>
        </div>
      </div>
    </div>

    <!-- AURORA (over list, under track art + player) -->
    <div class="aurora-layer" aria-hidden="true">
      <canvas id="aurora"></canvas>
    </div>

    <!-- player bar -->
    <div class="player-bar glass">
      <div class="now">
        <img id="nowArt" src="" alt="" class="now-art">
        <div class="now-meta">
          <span id="nowTitle">—</span>
          <small id="nowAlbum">—</small>
        </div>
      </div>

      <div class="controls">
        <button class="icon-btn" id="playAllBtn" title="Play entire library">
          <svg viewBox="0 0 24 24" width="18" height="18" aria-hidden="true">
            <path d="M5 7h8M5 12h14M5 17h10" stroke="currentColor" stroke-width="2" fill="none" stroke-linecap="round"/>
            <path d="M17 8v8l5-4z" fill="currentColor"/>
          </svg>
        </button>

        <button class="icon-btn" id="prevBtn" title="Previous">
          <svg viewBox="0 0 24 24" width="18" height="18"><path d="M6 6v12M18 6l-8 6 8 6V6z" fill="currentColor"/></svg>
        </button>

        <!-- PLAY/PAUSE -->
        <button class="icon-btn primary" id="playPauseBtn" title="Play / Pause" aria-pressed="false">
          <svg id="iconPlay" viewBox="0 0 24 24" width="20" height="20"><path d="M8 5v14l11-7z" fill="currentColor"/></svg>
          <svg id="iconPause" viewBox="0 0 24 24" width="20" height="20" hidden><path d="M7 5h4v14H7zM13 5h4v14h-4z" fill="currentColor"/></svg>
        </button>

        <button class="icon-btn" id="nextBtn" title="Next">
          <svg viewBox="0 0 24 24" width="18" height="18"><path d="M18 6v12M6 6l8 6-8 6V6z" fill="currentColor"/></svg>
        </button>
      </div>

      <div class="progress">
        <span id="currTime" class="time">0:00</span>
        <div class="bar">
          <div class="bar-track"></div>
          <div class="neon"></div>
          <input id="seek" type="range" min="0" max="1000" value="0" step="1" aria-label="Seek">
        </div>
        <span id="durTime" class="time">0:00</span>
      </div>

      <audio id="audio" preload="metadata" crossorigin="anonymous"></audio>
    </div>
  </div>

  <script>
  (function(){
    /* ---------------- DATA ---------------- */
    const tracks = [
      { title:"Rain",        src:"assets/tracks/Track 1.mp3", album:"Musings",              art:"assets/tracks/Musings.jpg" },
      { title:"Sonata",      src:"assets/tracks/Track 2.mp3", album:"Musings",              art:"assets/tracks/Musings.jpg" },
      { title:"Münchhausen", src:"assets/tracks/Track 3.mp3", album:"Musings",              art:"assets/tracks/Musings.jpg" },
      { title:"Growing Old", src:"assets/tracks/Track 4.mp3", album:"Musings",              art:"assets/tracks/Musings.jpg" },
      { title:"The Adventure Begins", src:"assets/tracks/Track 5.mp3", album:"The Adventure Begins", art:"assets/tracks/Musings.jpg" }
    ];

    const albumsMap = {};
    tracks.forEach(t => {
      if (!albumsMap[t.album]) albumsMap[t.album] = { art:t.art, tracks:[] };
      albumsMap[t.album].tracks.push(t);
    });
    const albums = Object.entries(albumsMap).sort((a,b)=> b[1].tracks.length - a[1].tracks.length);

    /* ---------------- ELTS ---------------- */
    const shell      = document.querySelector('.music-shell');
    const viewsWrap  = document.getElementById('viewsWrap');
    const albumsView = document.getElementById('albums-view');
    const trackView  = document.getElementById('track-view');
    const lightList  = document.getElementById('light-list');
    const lightTrack = document.getElementById('light-track');

    const audio   = document.getElementById('audio');
    const playBtn = document.getElementById('playPauseBtn');
    const iconPlay  = document.getElementById('iconPlay');
    const iconPause = document.getElementById('iconPause');
    const prevBtn = document.getElementById('prevBtn');
    const nextBtn = document.getElementById('nextBtn');
    const playAllBtn = document.getElementById('playAllBtn');
    const seek   = document.getElementById('seek');
    const neon   = document.querySelector('.bar .neon');
    const currTime = document.getElementById('currTime');
    const durTime  = document.getElementById('durTime');
    const nowArt   = document.getElementById('nowArt');
    const nowTitle = document.getElementById('nowTitle');
    const nowAlbum = document.getElementById('nowAlbum');
    const stageArt = document.getElementById('stage-art');

    /* ---------------- RENDER LIST ---------------- */
    function renderAlbums(){
      albumsView.innerHTML = albums.map(([name, data])=>{
        const items = data.tracks.map(t => `
          <li class="track-row" data-src="${t.src}" data-title="${t.title}" data-album="${name}" data-art="${data.art}">
            <span class="t-title">${t.title}</span>
            <span class="t-time">--:--</span>
          </li>`).join('');
        return `
          <article class="album-row" data-album="${name}">
            <div class="album-art-col"><img class="album-art" src="${data.art}" alt="${name} album art"></div>
            <div class="playlist-col">
              <header class="playlist-head">
                <h3>${name}</h3>
                <button class="icon-btn play-all" title="Play all in ${name}">
                  <svg viewBox="0 0 24 24" width="18" height="18" aria-hidden="true">
                    <path d="M5 7h8M5 12h14M5 17h10" stroke="currentColor" stroke-width="2" fill="none" stroke-linecap="round"/>
                    <path d="M17 8v8l5-4z" fill="currentColor"/>
                  </svg>
                </button>
              </header>
              <ul class="track-list">${items}</ul>
            </div>
          </article>`;
      }).join('');
    }
    renderAlbums();

    // set durations
    albumsView.querySelectorAll('.track-row').forEach(li=>{
      const a = new Audio(); a.src = li.dataset.src; a.preload='metadata';
      a.addEventListener('loadedmetadata', ()=>{ li.querySelector('.t-time').textContent = formatTime(a.duration); });
    });

    /* ---------------- PLAYER STATE ---------------- */
    let scope='album', queue=[], index=0;
    const allQueue = albums.flatMap(([n,d]) => d.tracks.map(t=>t));

    function setAlbumQueue(name){
      scope='album'; queue = albumsMap[name].tracks.slice(); index=0;
      document.querySelectorAll('.album-row').forEach(r=> r.classList.toggle('active', r.dataset.album===name));
    }

    function loadTrackBySrc(src){
      index = queue.findIndex(t => t.src===src); if (index<0) index=0;
      const t = queue[index];
      audio.preload = 'auto';
      audio.src = t.src;
      audio.load();

      nowArt.src = albumsMap[t.album].art;
      nowTitle.textContent = t.title;
      nowAlbum.textContent = t.album;
      stageArt.src = albumsMap[t.album].art;

      document.querySelectorAll('.track-row').forEach(r=> r.classList.toggle('active', r.dataset.src===t.src));
    }

    // Play/Pause BUTTON — robust swap
    function setPlayState(on){
      iconPlay.hidden = on;
      iconPause.hidden = !on;
      playBtn.setAttribute('aria-pressed', String(on));
    }
    function play(){ audio.play().catch(()=>{}); setPlayState(true); }
    function pause(){ audio.pause(); setPlayState(false); }

    playBtn.addEventListener('click', ()=> audio.paused ? play() : pause());
    audio.addEventListener('play',     ()=> setPlayState(true));
    audio.addEventListener('playing',  ()=> setPlayState(true));
    audio.addEventListener('pause',    ()=> setPlayState(false));
    audio.addEventListener('ended',    ()=> setPlayState(false));

    function next(auto=false){
      index = (index+1) % queue.length;
      loadTrackBySrc(queue[index].src);
      if (auto) { overlaySuppressed=false; startAurora(); }
      play();
    }
    function prev(){
      index = (index-1+queue.length) % queue.length;
      loadTrackBySrc(queue[index].src);
      play();
    }

    albumsView.addEventListener('click', e=>{
      const row = e.target.closest('.track-row');
      const playAll = e.target.closest('.play-all');
      const albumRow = e.target.closest('.album-row');

      if (playAll && albumRow){
        setAlbumQueue(albumRow.dataset.album);
        loadTrackBySrc(queue[0].src);
        play(); scheduleShow();
        return;
      }
      if (row){
        if (scope!=='album' || queue.length===0 || (queue[0].album !== row.dataset.album)){
          setAlbumQueue(row.dataset.album);
        }
        loadTrackBySrc(row.dataset.src);
        play(); scheduleShow();
      }
    });

    playAllBtn.addEventListener('click', ()=>{
      scope='all'; queue = allQueue.slice(); index=0;
      document.querySelectorAll('.album-row').forEach(r=> r.classList.remove('active'));
      loadTrackBySrc(queue[0].src); play(); scheduleShow();
      playAllBtn.classList.add('active'); setTimeout(()=> playAllBtn.classList.remove('active'), 260);
    });

    nextBtn.addEventListener('click', ()=> next(false));
    prevBtn.addEventListener('click', prev);

    // progress
    audio.addEventListener('timeupdate', ()=>{
      if (!isFinite(audio.duration)) return;
      seek.value = Math.floor(1000 * audio.currentTime / audio.duration);
      neon.style.setProperty('--pct', (audio.currentTime / audio.duration) * 100);
      currTime.textContent = formatTime(audio.currentTime);
      durTime.textContent  = formatTime(audio.duration);
    });
    seek.addEventListener('input', ()=>{
      if (isFinite(audio.duration)){
        audio.currentTime = (seek.value/1000) * audio.duration;
      }
    });
    audio.addEventListener('ended', ()=> { stopAurora(); next(true); });

    // modes
    function setMode(list){
      const isList = !!list;
      albumsView.classList.toggle('hidden', !isList);
      trackView.classList.toggle('hidden', isList);
      lightList.classList.toggle('on', isList);
      lightTrack.classList.toggle('on', !isList);
      shell.classList.toggle('track-bg', !isList);
      viewsWrap.classList.toggle('no-scroll', !isList);
      viewsWrap.scrollTop = 0;
    }
    lightList.addEventListener('click', ()=> setMode(true));
    lightTrack.addEventListener('click', ()=> setMode(false));

    /* ---------------- AURORA: bold, clear, smooth, reactive ---------------- */
    const auroraCanvas = document.getElementById('aurora');
    const ctx = auroraCanvas.getContext('2d');
    const auroraLayer = document.querySelector('.aurora-layer');

    let acx, srcNode, analyser;
    let rafId=null, showTimer=null, hoverTimer=null, silenceTimer=null;
    let overlayOn=false, overlaySuppressed=false;

    function ensureAudioGraph(){
      if (acx) return;
      acx = new (window.AudioContext || window.webkitAudioContext)();
      srcNode = acx.createMediaElementSource(audio);
      analyser = acx.createAnalyser();
      analyser.fftSize = 1024;               // reactive detail
      analyser.smoothingTimeConstant = 0.75; // keeps it snappy
      srcNode.connect(analyser); analyser.connect(acx.destination);
    }

    function sizeCanvas(){
      const r = auroraLayer.getBoundingClientRect();
      auroraCanvas.width  = Math.max(1, r.width|0);
      auroraCanvas.height = Math.max(1, r.height|0);
    }
    sizeCanvas(); addEventListener('resize', sizeCanvas);

    // seamless loop (color phase), but we crossfade gradients for *ultra* smooth morphing
    const LOOP_S = 120;
    const PHASE_MS = 36000; // crossfade length
    let t0 = performance.now();
    let phaseStart = performance.now();

    // gradient phase state
    let gradA = makePhase();
    let gradB = makePhase();

    function makePhase(){
      return {
        seed: Math.random()*360,
        n: pickCount(0),            // 3..7 (mostly 3–5)
        ang: (Math.random()*8-4) * Math.PI/180, // near-vertical
        offset: Math.random()*1000
      };
    }

    function pickCount(t){
      // Mostly 3–5, rarely 6–7 with soft chance
      const base = 3 + Math.round(1.2 + Math.sin(t*2*Math.PI*0.3)*1.3); // 3..5 mostly
      const rare = Math.random() < 0.08 ? (Math.random()<0.5?6:7) : base;
      return Math.max(3, Math.min(7, rare));
    }

    function loopT(){ const dt=(performance.now()-t0)/1000; return (dt%LOOP_S)/LOOP_S; }

    function startAurora(){ if(overlayOn) return; overlayOn=true; overlaySuppressed=false; auroraLayer.classList.add('on'); ensureAudioGraph(); draw(); }
    function stopAurora(){ overlayOn=false; auroraLayer.classList.remove('on'); if(rafId){cancelAnimationFrame(rafId); rafId=null;} }
    function scheduleShow(){ if(overlayOn||overlaySuppressed) return; clearTimeout(showTimer); showTimer=setTimeout(()=>{ if(!audio.paused) startAurora(); },20000); }

    // hover to hush
    shell.addEventListener('mouseenter', ()=>{
      if(!overlayOn) return;
      clearTimeout(hoverTimer);
      hoverTimer=setTimeout(()=>{ overlaySuppressed=true; stopAurora(); },5000);
    });
    shell.addEventListener('mouseleave', ()=>{
      clearTimeout(hoverTimer);
      if(!audio.paused){ overlaySuppressed=false; scheduleShow(); }
    });

    audio.addEventListener('play', ()=>{ ensureAudioGraph(); scheduleShow(); });
    audio.addEventListener('pause', ()=>{ clearTimeout(showTimer); stopAurora(); });

    function bandsFD(arr){
      const nyq = acx.sampleRate/2;
      const idx = hz => Math.min(arr.length-1, Math.max(0, Math.round(arr.length*(hz/nyq))));
      const avg = (lo,hi)=>{ let s=0,c=0; for(let i=lo;i<=hi;i++){ s+=arr[i]; c++; } return c? s/c : 0; };
      return { bass: avg(idx(20),idx(140)), mid: avg(idx(300),idx(2000)), treb: avg(idx(4000),idx(12000)) };
    }

    const smooth = { bass:0, mid:0, treb:0 };
    const lerp  = (a,b,t)=> a+(b-a)*t;

    function buildGradient(phase, tGlobal, w, h){
      // vertical orientation, slow tilt sometimes
      const drift = Math.sin(tGlobal*2*Math.PI*0.08)* (6*Math.PI/180);
      const ang = (Math.abs(phase.ang) < 0.02 ? 0 : phase.ang) + drift;

      const r = Math.hypot(w,h);
      const cx=w/2, cy=h*0.65;
      const x0=cx - Math.cos(ang)*r/2, y0=cy - Math.sin(ang)*r/2;
      const x1=cx + Math.cos(ang)*r/2, y1=cy + Math.sin(ang)*r/2;

      const g = ctx.createLinearGradient(x0,y0,x1,y1);
      const n = phase.n;
      for(let i=0;i<n;i++){
        const f = i/(n-1 || 1);
        const hue = (phase.seed + i*(360/n) + 28*Math.sin(2*Math.PI*(tGlobal*0.06 + phase.offset + i*0.07))) % 360;

        // main stop (nearly opaque)
        g.addColorStop(Math.max(0, Math.min(1, f)), `hsla(${hue} 90% 56% / 0.96)`);

        // mid stop to soften transition
        if(i<n-1){
          const mid = f + (1/(n-1))*0.5;
          const hue2 = (hue + 24) % 360;
          g.addColorStop(Math.max(0, Math.min(1, mid)), `hsla(${hue2} 88% 58% / 0.90)`);
        }
      }
      return g;
    }

    function draw(){
      if(!overlayOn) return;
      rafId=requestAnimationFrame(draw);
      sizeCanvas();

      const w=auroraCanvas.width, h=auroraCanvas.height;
      ctx.clearRect(0,0,w,h);

      // audio data
      const td = new Uint8Array(1024);
      analyser.getByteTimeDomainData(td);
      let sum=0; for(let i=0;i<td.length;i++){ const v=(td[i]-128)/128; sum+=v*v; }
      const rms = Math.sqrt(sum/td.length); // ~0..1

      const fd = new Uint8Array(analyser.frequencyBinCount);
      analyser.getByteFrequencyData(fd);
      const bd = bandsFD(fd);
      smooth.bass = lerp(smooth.bass, bd.bass/255, 0.25);
      smooth.mid  = lerp(smooth.mid,  bd.mid/255,  0.22);
      smooth.treb = lerp(smooth.treb, bd.treb/255, 0.20);

      const tLoop = loopT();
      const now = performance.now();
      let cross = (now - phaseStart) / PHASE_MS;
      if (cross >= 1){
        // roll to next phase
        gradA = gradB;
        gradB = makePhase();
        phaseStart = now;
        cross = 0;
      }

      // wave silhouette (curtain-like)
      const baseAmp = h*(0.22 + 0.40*rms);           // bold
      const kx = 2*Math.PI/Math.max(360,w);
      const ph = tLoop*2*Math.PI*0.8;

      // column modulation → aurora curtains
      const cols = 6;
      const colAmp = (x)=> {
        let v=0;
        for(let c=1;c<=cols;c++){
          v += Math.sin((c*0.3)*kx*x + ph*c*0.3) / c;
        }
        return (v/cols)*0.6 + 0.7; // 0.1..1.3 approx
      };

      ctx.save();
      ctx.beginPath();
      ctx.moveTo(0,h);
      const steps=140;
      for(let i=0;i<=steps;i++){
        const x=(i/steps)*w;
        const yWave =
          Math.sin(kx*x + ph) * (0.55 + 0.35*smooth.mid) +
          Math.sin(kx*1.7*x + ph*1.25) * (0.30 + 0.30*smooth.treb) +
          Math.sin(kx*3.2*x + ph*0.9) * (0.22 + 0.18*smooth.treb);

        const energy = 0.55*smooth.bass + 0.35*smooth.mid + 0.10*smooth.treb;
        const curtain = colAmp(x);
        const y = h - (h*0.10 + baseAmp*(0.5+0.5*yWave)*(0.75 + 0.45*energy)*curtain);
        ctx.lineTo(x,y);
      }
      ctx.lineTo(w,h); ctx.closePath();
      ctx.clip();

      // gradients: crossfade A→B to avoid any pop
      const gA = buildGradient(gradA, (now/1000), w, h);
      const gB = buildGradient(gradB, (now/1000), w, h);

      // pass 1: crisp
      ctx.globalCompositeOperation='screen';
      ctx.globalAlpha = 1 - cross;
      ctx.fillStyle = gA;
      ctx.fillRect(0,0,w,h);

      ctx.globalAlpha = cross;
      ctx.fillStyle = gB;
      ctx.fillRect(0,0,w,h);

      // pass 2: gentle merge
      ctx.globalAlpha = 0.9;
      ctx.filter = 'blur(5px)';
      ctx.fillStyle = gA;
      ctx.fillRect(0,0,w,h);
      ctx.globalAlpha = cross;
      ctx.fillStyle = gB;
      ctx.fillRect(0,0,w,h);
      ctx.filter = 'none';
      ctx.globalAlpha = 1;

      // fade top only (aurora taper)
      const fade = ctx.createLinearGradient(0, 0, 0, h);
      fade.addColorStop(0.00, 'rgba(0,0,0,1)');
      fade.addColorStop(0.18, 'rgba(0,0,0,0.35)');
      fade.addColorStop(0.36, 'rgba(0,0,0,0)');
      ctx.globalCompositeOperation='destination-out';
      ctx.fillStyle=fade;
      ctx.fillRect(0,0,w,h);

      ctx.restore();
    }

    // boot
    setAlbumQueue(albums[0][0]);
    loadTrackBySrc(albumsMap[albums[0][0]].tracks[0].src);
    setMode(true);
    setPlayState(false);
  })();

  function formatTime(t){ const m=Math.floor(t/60); const s=Math.floor(t%60).toString().padStart(2,'0'); return `${m}:${s}`; }
  </script>
</section>
