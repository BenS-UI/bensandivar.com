<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>WebGL â€¢ Klein Particles (Minimal)</title>
<style>
html, body { height:100%; margin:0; background:transparent; }
body { overflow:hidden; }
canvas { display:block; width:100vw; height:100vh; background:transparent; }
</style>
</head>
<body>
<canvas id="gl"></canvas>
<script>
(function(){
  const DPR = Math.min(2, window.devicePixelRatio || 1);
  const canvas = document.getElementById('gl');
  const gl = canvas.getContext('webgl2', {antialias:true, alpha:true, premultipliedAlpha:false});
  if(!gl){ document.body.innerHTML = '<div style="padding:20px;font:14px system-ui;color:#fff;background:#000">WebGL2 required</div>'; return; }

  function resize(){ const w = Math.max(1, canvas.clientWidth), h = Math.max(1, canvas.clientHeight); canvas.width = Math.floor(w*DPR); canvas.height = Math.floor(h*DPR); gl.viewport(0,0,canvas.width,canvas.height); }
  window.addEventListener('resize', resize, {passive:true}); resize();

  const PARTICLES = Math.min(90000, Math.floor((navigator.hardwareConcurrency||4)*12000));

  const seed = new Float32Array(PARTICLES*2);
  for(let i=0;i<PARTICLES;i++){ const u=i/PARTICLES; const v=((i*16807)%PARTICLES)/PARTICLES; seed[i*2]=u; seed[i*2+1]=v; }

  const vert = `#version 300 es
  precision highp float;
  layout(location=0) in vec2 a_uv;
  uniform float u_time; uniform float u_dt; uniform vec3 u_mouseW; uniform float u_follow;
  uniform mat4 u_proj, u_view; uniform float u_point;
  out vec3 v_col; out float v_depth; out float v_soft;

  vec3 klein(float u,float v){
    float cu=cos(u), su=sin(u); float c2=cos(u*0.5), s2=sin(u*0.5);
    float sv=sin(v), s2v=sin(2.0*v);
    float x=(2.0 + c2*sv - s2*s2v)*cu;
    float y=(2.0 + c2*sv - s2*s2v)*su;
    float z=s2*sv + c2*s2v;
    return vec3(x,y,z);
  }

  vec3 palette(float t){
    vec3 indigo = vec3(0.05,0.00,0.18);
    vec3 eblue  = vec3(0.12,0.60,1.00);
    vec3 aqua   = vec3(0.00,0.95,0.86);
    return mix(mix(indigo, eblue, smoothstep(0.0,0.5,t)), mix(eblue, aqua, smoothstep(0.5,1.0,t)), step(0.5,t));
  }

  mat3 rotY(float a){ float c=cos(a), s=sin(a); return mat3(c,0.0,s, 0.0,1.0,0.0, -s,0.0,c); }
  mat3 rotX(float a){ float c=cos(a), s=sin(a); return mat3(1.0,0.0,0.0, 0.0,c,-s, 0.0,s,c); }

  void main(){
    float U = a_uv.x * 6.28318530718; // 0..2pi
    float V = a_uv.y * 6.28318530718;

    vec3 p = klein(U,V) * 2.1;
    p = rotY(u_time*0.12) * rotX(u_time*0.05) * p;

    vec3 d = u_mouseW - p; // attract in 3D
    float r2 = dot(d,d) + 1e-6;
    float influence = 1.0 / (1.0 + r2*0.15);
    float k = 1.0 - exp(-u_dt*6.0);
    p += d * (u_follow * influence * k);

    vec4 wp = u_view * vec4(p,1.0);
    vec4 cp = u_proj * wp; gl_Position = cp;
    float depth = max(0.0001, -wp.z);
    gl_PointSize = clamp((u_point/depth)*18.0, 1.5, 3.0);

    float hue = fract(a_uv.x*0.25 + a_uv.y*0.75 + 0.15*sin(u_time*0.4));
    v_col = palette(hue);
    v_depth = depth; v_soft = 0.10;
  }`;

  const frag = `#version 300 es
  precision highp float; in vec3 v_col; in float v_depth; in float v_soft; out vec4 o;
  void main(){
    vec2 uv = gl_PointCoord*2.0-1.0; float r2 = dot(uv,uv); if(r2>1.0) discard;
    float core = 1.0 - smoothstep(0.0, 0.85, r2);
    float glow = smoothstep(0.55, 1.0, r2) * v_soft;
    float a = clamp(core*0.92 + glow*0.08, 0.0, 0.9);
    float dim = clamp(1.0/(1.0+v_depth*0.25), 0.70, 1.0);
    vec3 col = normalize(v_col + vec3(0.04)) * dim;
    o = vec4(col, a);
  }`;

  function makeShader(src,type){ const s=gl.createShader(type); gl.shaderSource(s,src); gl.compileShader(s); if(!gl.getShaderParameter(s,gl.COMPILE_STATUS)){ throw new Error(gl.getShaderInfoLog(s)); } return s; }
  function makeProgram(vs,fs){ const p=gl.createProgram(); gl.attachShader(p,makeShader(vs,gl.VERTEX_SHADER)); gl.attachShader(p,makeShader(fs,gl.FRAGMENT_SHADER)); gl.linkProgram(p); if(!gl.getProgramParameter(p,gl.LINK_STATUS)){ throw new Error(gl.getProgramInfoLog(p)); } return p; }

  const prog = makeProgram(vert,frag); gl.useProgram(prog);
  gl.enable(gl.BLEND); gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
  gl.clearColor(0,0,0,0);

  const buf = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, buf); gl.bufferData(gl.ARRAY_BUFFER, seed, gl.STATIC_DRAW);
  gl.enableVertexAttribArray(0); gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);

  const uni = {
    time: gl.getUniformLocation(prog,'u_time'),
    dt: gl.getUniformLocation(prog,'u_dt'),
    mouseW: gl.getUniformLocation(prog,'u_mouseW'),
    follow: gl.getUniformLocation(prog,'u_follow'),
    proj: gl.getUniformLocation(prog,'u_proj'),
    view: gl.getUniformLocation(prog,'u_view'),
    point: gl.getUniformLocation(prog,'u_point')
  };

  function perspective(fovy, aspect, near, far){
    const f = 1/Math.tan(fovy/2), nf = 1/(near - far); const m = new Float32Array(16);
    m[0]=f/aspect; m[5]=f; m[10]=(far+near)*nf; m[11]=-1; m[14]=(2*far*near)*nf; return m;
  }
  function lookAt(eye,center,up){
    let fx=center[0]-eye[0], fy=center[1]-eye[1], fz=center[2]-eye[2]; let rl=1/Math.hypot(fx,fy,fz); fx*=rl; fy*=rl; fz*=rl;
    let sx=fy*up[2]-fz*up[1], sy=fz*up[0]-fx*up[2], sz=fx*up[1]-fy*up[0]; rl=1/Math.hypot(sx,sy,sz); sx*=rl; sy*=rl; sz*=rl;
    const ux=sy*fz - sz*fy, uy=sz*fx - sx*fz, uz=sx*fy - sy*fx; const m=new Float32Array(16);
    m[0]=sx; m[1]=ux; m[2]=-fx; m[4]=sy; m[5]=uy; m[6]=-fy; m[8]=sz; m[9]=uz; m[10]=-fz; m[15]=1;
    m[12]=-(sx*eye[0]+sy*eye[1]+sz*eye[2]); m[13]=-(ux*eye[0]+uy*eye[1]+uz*eye[2]); m[14]=(fx*eye[0]+fy*eye[1]+fz*eye[2]);
    return m;
  }

  const CAMERA_DIST = 13.0;
  function screenToWorldAtZ0(ndc){ const aspect=canvas.width/canvas.height; const fovy=60*Math.PI/180; const tanF=Math.tan(fovy/2); const rx=ndc[0]*aspect*tanF; const ry=ndc[1]*tanF; const origin=[0,0,CAMERA_DIST]; const dir=[rx,ry,-1]; const t=(0-origin[2])/dir[2]; return [origin[0]+dir[0]*t, origin[1]+dir[1]*t, 0]; }

  let mouseInside=false; let mouseN=[9,9]; let mouseSm=[9,9];
  let follow=0.0;
  function setMouse(e){ const r=canvas.getBoundingClientRect(); const x=((e.clientX-r.left)/r.width)*2-1; const y=-(((e.clientY-r.top)/r.height)*2-1); mouseN=[x,y]; mouseInside=true; }
  canvas.addEventListener('mousemove', setMouse, {passive:true});
  canvas.addEventListener('mouseenter', e=>{ setMouse(e); mouseInside=true; }, {passive:true});
  canvas.addEventListener('mouseleave', ()=>{ mouseInside=false; mouseN=[9,9]; }, {passive:true});
  canvas.addEventListener('touchstart', e=>{ const t=e.changedTouches[0]; setMouse(t); mouseInside=true; }, {passive:true});
  canvas.addEventListener('touchmove', e=>{ const t=e.changedTouches[0]; setMouse(t); }, {passive:true});
  canvas.addEventListener('touchend', ()=>{ mouseInside=false; mouseN=[9,9]; }, {passive:true});

  let prev=performance.now();
  function frame(nowMS){
    const dt = Math.min(0.05, (nowMS - prev)/1000); prev = nowMS;

    const k = 1 - Math.exp(-dt*8.0);
    mouseSm[0] += (mouseN[0]-mouseSm[0]) * k;
    mouseSm[1] += (mouseN[1]-mouseSm[1]) * k;

    const proj = perspective(60*Math.PI/180, canvas.width/canvas.height, 0.1, 100.0);
    const view = lookAt([0,0,CAMERA_DIST],[0,0,0],[0,1,0]);

    gl.clear(gl.COLOR_BUFFER_BIT);
    gl.useProgram(prog);
    gl.uniform1f(uni.time, nowMS/1000);
    gl.uniform1f(uni.dt, dt);

    const mouseW = screenToWorldAtZ0(mouseSm);
    gl.uniform3f(uni.mouseW, mouseW[0], mouseW[1], mouseW[2]);

    const targetFollow = mouseInside ? 0.9 : 0.0;
    follow += (targetFollow - follow) * (1 - Math.exp(-dt*6.0));
    gl.uniform1f(uni.follow, follow);

    gl.uniformMatrix4fv(uni.proj, false, proj);
    gl.uniformMatrix4fv(uni.view, false, view);
    gl.uniform1f(uni.point, 2.0*DPR);

    gl.drawArrays(gl.POINTS, 0, PARTICLES);
    requestAnimationFrame(frame);
  }
  requestAnimationFrame(frame);
})();
</script>
</body>
</html>